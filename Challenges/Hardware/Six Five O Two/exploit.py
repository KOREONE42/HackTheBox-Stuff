#!/usr/bin/env python3
import argparse
import re
import socket
import sys
from typing import List, Tuple

HOST = "94.237.54.98"
PORT = 45100

# ---------------- ROM builder ----------------
def build_rom() -> bytes:
    rom = bytearray(0x8000)  # $8000-$FFFF, 32KB
    code = [
        0xA2, 0x00,             # LDX #$00
        0xBD, 0x00, 0x40,       # LDA $4000,X
        0x9D, 0x00, 0x60,       # STA $6000,X
        0xE8,                   # INX
        0xE0, 0x20,             # CPX #$20
        0xD0, 0xF5,             # BNE LOOP
    ]
    rom[:len(code)] = bytes(code)

    def set_word(addr: int, val: int):
        off = addr - 0x8000
        rom[off] = val & 0xFF
        rom[off+1] = (val >> 8) & 0xFF

    set_word(0xFFFA, 0xFFFF)   # NMI
    set_word(0xFFFC, 0x8000)   # RESET
    set_word(0xFFFE, 0xFFFF)   # IRQ/BRK
    return bytes(rom)

# --------------- I/O helpers ----------------
def recv_until(sock: socket.socket, token: bytes, timeout: float = 30.0) -> bytes:
    sock.settimeout(timeout)
    data = b""
    while token not in data:
        chunk = sock.recv(4096)
        if not chunk:
            break
        data += chunk
    return data

def sendline(sock: socket.socket, line: str) -> None:
    sock.sendall(line.encode("ascii") + b"\n")

# --------------- Parsing helpers ---------------
HEX_PAIR = re.compile(r"(?i)(?<![0-9A-F])([0-9A-F]{2})(?![0-9A-F])")

def extract_hex_pairs(s: str) -> List[str]:
    return HEX_PAIR.findall(s)

def parse_console_block(out_bytes: bytes) -> Tuple[str, bytes]:
    """
    Parse the 32 console bytes from the server text:
    - Restrict strictly to text *before* the final 'READY.' line.
    - Extract all hex pairs in order as they appear in the console output.
    """
    text = out_bytes.decode("ascii", errors="ignore")

    # Find the last READY. (strip any trailing whitespace differences)
    ready_idx = text.rfind("READY.")
    body = text[:ready_idx] if ready_idx != -1 else text

    # Extract all hex pairs in order from the console output
    all_pairs = extract_hex_pairs(body)
    
    if len(all_pairs) < 33:
        # Provide detailed context to debug
        raise ValueError(
            f"Could not recover 32 console bytes. Found {len(all_pairs)} pairs.\n"
            "----- BEFORE READY. (sanitized) -----\n"
            + body
            + "\n-------------------------------------"
        )

    chosen = all_pairs[:33]
    b = bytes(int(h, 16) for h in chosen)
    return body, b

def bytes_to_ascii(b: bytes) -> str:
    return b.decode("ascii", errors="ignore")

# --------------- Main solve path ---------------
def run_solver(host: str, port: int, steps: int = 260):
    rom_hex = build_rom().hex().upper()
    with socket.create_connection((host, port), timeout=15.0) as s:
        # banner
        _ = recv_until(s, b"READY.")
        # flash (auto-reset)
        sendline(s, "FLASH " + rom_hex)
        _ = recv_until(s, b"READY.", timeout=60.0)
        # run a comfortable amount of steps
        sendline(s, f"RUN {steps}")
        _ = recv_until(s, b"READY.", timeout=30.0)
        # dump console (capture *only* server output here)
        sendline(s, "CONSOLE")
        out = recv_until(s, b"READY.", timeout=15.0)

    before_ready, console_bytes = parse_console_block(out)
    ascii_text = bytes_to_ascii(console_bytes)
    return before_ready, console_bytes, ascii_text

# --------------- CLI ---------------
def main():
    ap = argparse.ArgumentParser(description="Six Five O Two robust solver + hexâ†’ASCII")
    ap.add_argument("--host", default=HOST)
    ap.add_argument("--port", type=int, default=PORT)
    ap.add_argument("--steps", type=int, default=260)
    ap.add_argument("--from-raw", metavar="TEXT_OR_-",
                    help="Convert pasted RAW console text (string) or '-' to read from stdin; skips network")
    args = ap.parse_args()

    if args.from_raw is not None:
        raw = sys.stdin.read() if args.from_raw == "-" else args.from_raw
        try:
            body, b = parse_console_block(raw.encode("ascii", "ignore"))
            print("[+] Parsed 32 bytes:", b.hex(" ").upper())
            print("[+] ASCII:", bytes_to_ascii(b))
        except Exception as e:
            pairs = extract_hex_pairs(raw)
            if len(pairs) >= 32:
                b = bytes(int(x, 16) for x in pairs[:32])
                print("[*] Fallback used. Parsed 32 bytes:", b.hex(" ").upper())
                print("[*] ASCII:", bytes_to_ascii(b))
            else:
                print("[-] Error:", e)
        return

    print(f"[+] Connecting to {args.host}:{args.port}")
    try:
        body, b, ascii_text = run_solver(args.host, args.port, args.steps)
        print("[+] Console (server text before READY.):\n" + body.strip())
        print("[+] Console bytes:", b.hex(" ").upper())
        print("[+] ASCII:", ascii_text)
        m = re.search(r"(HTB\{[^}]*\})", ascii_text)
        if m:
            print("[+] Flag:", m.group(1))
        else:
            print("[-] Flag pattern not found (but ASCII shown above).")
    except Exception as e:
        print("[-] Error:", e)

if __name__ == "__main__":
    main()