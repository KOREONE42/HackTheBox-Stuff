from pwn import *
import base64
import tempfile

# Connection details
HOST = '83.136.253.201'
PORT = 58410

# Number of rounds to solve (including warmup)
ROUNDS = 129  # 1 warmup + 128 challenge binaries


def get_loaded_value(e: ELF) -> bytes:
    """
    Given a pwntools ELF object, extract the 0x18-byte data copied to stack by the entrypoint.
    """
    # The lea instruction is 4 bytes past entrypoint
    lea_addr = e.entrypoint + 4
    # Read the 32-bit signed offset after the lea opcode
    offset = u32(e.read(lea_addr + 3, 4), sign='signed')
    # Compute target address: address after lea (7 bytes) plus offset
    target = lea_addr + 7 + offset
    # Read 0x18 bytes from target
    return e.read(target, 0x18)


def do_round(r: remote) -> None:
    """
    Perform one round: receive base64 ELF, decode, extract expected bytes, and send hex.
    """
    # Wait for base64-encoded ELF
    r.recvuntil(b'ELF: ')
    b64_elf = r.recvline().strip()

    # Decode and write to temporary file
    elf_data = base64.b64decode(b64_elf)
    with tempfile.NamedTemporaryFile(prefix='quickscan_', suffix='.elf') as f:
        f.write(elf_data)
        f.flush()

        # Load ELF and extract the 0x18-byte value
        e = ELF(f.name)
        data = get_loaded_value(e)

    # Send the hex string when prompted
    r.sendlineafter(b'Bytes? ', data.hex().encode())


def main():
    # Connect to remote service
    r = remote(HOST, PORT)

    # Solve all rounds
    for i in range(ROUNDS):
        do_round(r)
        log.progress(f'Solved round', i + 1)

    # Hand over interaction to user (flag should arrive)
    r.interactive()


if __name__ == '__main__':
    main()
