import struct
from pathlib import Path

def decryptor(file_path: str, plain_size: int = 4056) -> bytes:
    """
    Decrypts a custom 8-byte-block encoded file.

    The encryption format splits the ciphertext into 8-byte little-endian blocks.
    Each block is interpreted as an unsigned 64-bit integer. The decryption works in
    rounds (0 to 254):
      1. Read a block to get `count` (number of offsets to follow).
      2. For `count` times, read an offset block and write the current round byte
         value into the plaintext at that offset.

    Args:
        file_path (str): Path to the encrypted file.
        plain_size (int): Expected size of the plaintext buffer. Defaults to 4056.

    Returns:
        bytes: The decrypted plaintext, trailing null bytes removed.
    """
    # Read raw data from the file
    data = Path(file_path).read_bytes()

    # Create an iterator over 8-byte little-endian unsigned integers
    blocks = struct.iter_unpack('<Q', data)

    # Preallocate plaintext buffer
    plain = bytearray(plain_size)

    # Perform decryption rounds for byte values 0 through 254
    for byte_value in range(255):
        try:
            # The first block in each round is the number of following offsets
            count, = next(blocks)
        except StopIteration:
            # No more data: end decryption
            break

        # Write `byte_value` at each specified offset
        for _ in range(count):
            try:
                offset, = next(blocks)
            except StopIteration:
                raise ValueError("Unexpected end of data while reading offsets.")

            if offset >= plain_size:
                raise ValueError(f"Offset {offset} out of bounds (max {plain_size-1}).")
            plain[offset] = byte_value

    # Remove any trailing null bytes and return
    return bytes(plain).rstrip(b"\x00")


if __name__ == '__main__':
    # Example usage: decrypt and print the message
    message = decryptor("message.txt.cz")
    print(message.decode())
