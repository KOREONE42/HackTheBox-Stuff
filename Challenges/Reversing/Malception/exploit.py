import base64
import operator
import xml.etree.ElementTree as ET

import pyshark
import pefile
from Crypto.Cipher import ARC4, AES, PKCS1_v1_5
from Crypto.Protocol.KDF import PBKDF2
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import pad, unpad
from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b


# -------------------------
# Utilities
# -------------------------
def xor_bytes(data: bytes, key: bytes) -> bytes:
    return bytes([operator.xor(b, key[i % len(key)]) for i, b in enumerate(data)])


def rc4_decrypt_bytes(rc4_key: bytes, ciphertext: bytes) -> bytes:
    return ARC4.new(rc4_key).decrypt(ciphertext)


# -------------------------
# Graphy (AES-CBC with PBKDF2)
# -------------------------
class AesCbcWithPbkdf2:
    Iterations = 2
    KeySize = 256  # bits
    Salt = bytes([21, 204, 127, 153, 3, 237, 10, 26, 19, 103, 23, 31, 55, 49, 32, 57])

    @staticmethod
    def encrypt(data: bytes, password: str) -> bytes:
        return AesCbcWithPbkdf2._crypt(AES, data, password, encrypt=True)

    @staticmethod
    def decrypt(data: bytes, password: str) -> bytes:
        return AesCbcWithPbkdf2._crypt(AES, data, password, encrypt=False)

    @staticmethod
    def _crypt(cipher_cls, data: bytes, password: str, encrypt: bool) -> bytes:
        key_len = AesCbcWithPbkdf2.KeySize // 8  # 32 bytes
        password_bytes = password.encode('utf-8')
        kdf = PBKDF2(password_bytes, AesCbcWithPbkdf2.Salt, dkLen=key_len + 16, count=AesCbcWithPbkdf2.Iterations)
        key = kdf[:key_len]
        iv = kdf[key_len:key_len + 16]
        cipher = cipher_cls.new(key, AES.MODE_CBC, iv)
        if encrypt:
            return cipher.encrypt(pad(data, AES.block_size))
        else:
            return unpad(cipher.decrypt(data), AES.block_size)


# -------------------------
# Stego (RSA helpers)
# -------------------------
def _b64encode_int(n: int) -> str:
    return base64.b64encode(l2b(n)).decode('ascii')


def _b64decode_int(b64_string: str) -> int:
    return b2l(base64.b64decode(b64_string))


class RsaXml:
    @staticmethod
    def parse_private_key(xml_bytes: bytes) -> RSA.RsaKey:
        root = ET.fromstring(xml_bytes)
        get = lambda name: _b64decode_int(root.findtext(name))
        n = get('Modulus')
        e = get('Exponent')
        d = get('D')
        p = get('P')
        q = get('Q')
        return RSA.construct((n, e, d, p, q))

    @staticmethod
    def decrypt_pkcs1_v1_5(ciphertext: bytes, private_key: RSA.RsaKey) -> bytes:
        cipher = PKCS1_v1_5.new(private_key)
        sentinel = b'\x00' * 16
        out = cipher.decrypt(ciphertext, sentinel)
        if out == sentinel:
            raise ValueError('RSA decryption failed')
        return out


# -------------------------
# ExfilBlock (parsers + decrypt)
# -------------------------
class ExfilBlockParser:
    def __init__(self, block: bytes):
        self.offset = 0
        self.total_len = len(block)
        self.data = block

    def parse_length_prefixed_block(self) -> bytes:
        i_bye = self.data[self.offset:].find(b'\n\n')
        content_len = self.data[self.offset:self.offset + i_bye + 1].decode().strip()
        if not content_len.isnumeric():
            raise ValueError('Malformed block length header')
        content_len = int(content_len)
        self.offset += i_bye + 1
        # Expect a single newline delimiter
        if self.data[self.offset:self.offset + 1] != b'\n':
            raise ValueError('Malformed block delimiter')
        self.offset += 1
        content = self.data[self.offset:self.offset + content_len]
        self.offset += content_len
        # Next separator: either '\n' if more blocks follow, or 'end' terminator
        remaining = self.total_len - self.offset
        if remaining > 3:
            if self.data[self.offset:self.offset + 1] != b'\n':
                raise ValueError('Malformed block trailer')
            self.offset += 1
        else:
            if self.data[self.offset:self.offset + 3] != b'end':
                raise ValueError('Missing end terminator')
            self.offset += 3
        return content

    def deserialize_block(self):
        encrypted_key_and_key2_xor = self.parse_length_prefixed_block()
        encrypted_filename_xor = self.parse_length_prefixed_block()
        encrypted_content = self.parse_length_prefixed_block()
        return encrypted_key_and_key2_xor, encrypted_filename_xor, encrypted_content


class CorpDecryptor:
    @staticmethod
    def decrypt_file(block_buffer: bytes, xor_key: bytes):
        encrypted_keys, encrypted_filename, encrypted_content = ExfilBlockParser(block_buffer).deserialize_block()
        file_path = xor_bytes(encrypted_filename, xor_key).decode()
        if not file_path.endswith('.enc'):
            raise ValueError('Unexpected filename suffix')
        file_path = file_path[:-4]

        key_stream = xor_bytes(encrypted_keys, xor_key)
        xml_key_offset = key_stream.find(b'<RSAKeyValue')
        xml_key_blob = key_stream[xml_key_offset:]
        encrypted_session_key = encrypted_keys[:xml_key_offset]

        rsa_private = RsaXml.parse_private_key(xml_key_blob)
        session_key = RsaXml.decrypt_pkcs1_v1_5(encrypted_session_key, rsa_private)
        session_key_b64 = base64.b64encode(session_key).decode()
        decrypted_content = AesCbcWithPbkdf2.decrypt(encrypted_content, session_key_b64)
        return file_path, decrypted_content

    @staticmethod
    def decrypt_files(block_buffers: list, xor_key: bytes):
        for block in block_buffers:
            file_path, decrypted_content = CorpDecryptor.decrypt_file(block, xor_key)
            with open(file_path, 'wb') as of:
                of.write(decrypted_content)
            print(f'Wrote {len(decrypted_content)} bytes to {file_path}')


# -------------------------
# PCAP + PE parsing and DLL patching
# -------------------------
def extract_stages_from_pcap(pcap_path: str):
    discovered_hostnames = set()
    stage1_packets = []
    stage2_blocks = []
    reassembly_buffer = b''
    cap = pyshark.FileCapture(pcap_path, display_filter='tcp')
    try:
        for pkt in cap:
            if any(layer.layer_name == 'kerberos' for layer in pkt.layers):
                username = pkt.kerberos.get('CNameString')
                hostname = pkt.kerberos.get('realm')
                if username and hostname:
                    discovered_hostnames.add('.'.join(hostname.split('.')[:-1]))
            elif any(layer.layer_name == 'DATA' for layer in pkt.layers):
                tport = f'{pkt.tcp.srcport}_{pkt.tcp.dstport}'
                if '8000' in tport:
                    continue
                if '31337' in tport:
                    if pkt.tcp.srcport == '31337':
                        stage1_packets.append(bytes.fromhex(pkt.data.data))
                elif '31338' in tport:
                    byte_data = bytes.fromhex(pkt.data.data)
                    reassembly_buffer += byte_data
                    if byte_data == b'end':
                        stage2_blocks.append(reassembly_buffer)
                        reassembly_buffer = b''
    finally:
        cap.close()
    return list(discovered_hostnames), stage1_packets, stage2_blocks


def derive_rc4_key_and_stage1_plaintext(stage1_packets, hostname_bytes: bytes):
    rc4_key = None
    concatenated_payload = b''
    for packet in stage1_packets:
        if rc4_key is None and len(packet) == 8:
            rc4_key = xor_bytes(packet, hostname_bytes)
        else:
            concatenated_payload += packet
    stage1_plaintext = rc4_decrypt_bytes(rc4_key, concatenated_payload)
    assert len(stage1_plaintext) == 7680
    return rc4_key, stage1_plaintext


def extract_rcdata_resource(pe_path, resource_type=0xA, resource_id=0x65):
    pe = pefile.PE(pe_path)
    for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries:
        if entry.id == resource_type:
            for subentry in entry.directory.entries:
                if subentry.id == resource_id:
                    data_rva = subentry.directory.entries[0].data.struct.OffsetToData
                    size = subentry.directory.entries[0].data.struct.Size
                    return pe.get_memory_mapped_image()[data_rva:data_rva + size]
    raise RuntimeError('Resource not found')


def assemble_dotnet_image(stage1_plaintext, resource_plain):
    resource_bytes = bytearray(resource_plain)
    stage1_bytes = bytearray(stage1_plaintext)
    for i in range(len(resource_bytes)):
        stage1_bytes[3504 + i] = resource_bytes[i]
    return bytes(stage1_bytes)


def build_patched_dotnet_dll(stage1_packets, hostname_bytes, pe_path, output_name='CorpSpace.dll'):
    rc4_key, stage1_plaintext = derive_rc4_key_and_stage1_plaintext(stage1_packets, hostname_bytes)
    encrypted_resource = extract_rcdata_resource(pe_path)
    resource_plain = rc4_decrypt_bytes(rc4_key, encrypted_resource)
    dotnet_image = assemble_dotnet_image(stage1_plaintext, resource_plain)
    with open(output_name, 'wb') as of:
        of.write(dotnet_image)
    print(f'Wrote {len(dotnet_image)} to {output_name}')
    return rc4_key


if __name__ == '__main__':
    hostnames, stage1_packets, stage2_blocks = extract_stages_from_pcap('capture.pcapng')
    assert len(hostnames) == 1
    hostname_bytes = hostnames[0].encode()
    rc4_key = build_patched_dotnet_dll(stage1_packets, hostname_bytes, 'xQWdrq.exe')
    CorpDecryptor.decrypt_files(stage2_blocks, rc4_key)
