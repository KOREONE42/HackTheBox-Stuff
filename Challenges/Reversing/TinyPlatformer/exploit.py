#!/usr/bin/env python3
from z3 import Solver, Int, Distinct
from pwn import xor

def solve_level(size, conds):
    s = Solver()
    xs = [Int(f'x{i}') for i in range(size)]
    # add all ordering constraints
    for c in conds:
        s.add(c(xs))
    # all indices must be distinct and in [0, size)
    s.add(Distinct(*xs))
    for x in xs:
        s.add(x >= 0, x < size)
    assert s.check().r == 1, "unsat!"
    m = s.model()
    # build the byte‐string of digits
    return b''.join(str(m[x].as_long()).encode() for x in xs)

def main():
    # this byte‐string is hard‐coded in the decompiled PyInstaller executable:
    ciph = b'}dvIA_\x00FV\x01A^\x01CoG\x03BD\x00]SO'
    # constraints for each of the three levels (6, 5, and 4 collectibles)
    constraints = [
        # Level 1 (6 collectibles)
        [
            lambda x: x[0] > x[2],
            lambda x: x[1] < x[4],
            lambda x: x[2] > x[5],
            lambda x: x[3] > x[4],
            lambda x: x[5] > x[3],
        ],
        # Level 2 (5 collectibles)
        [
            lambda x: x[0] > x[4],
            lambda x: x[1] < x[4],
            lambda x: x[2] < x[3],
            lambda x: x[3] < x[1],
        ],
        # Level 3 (4 collectibles)
        [
            lambda x: x[0] > x[1],
            lambda x: x[2] < x[1],
            lambda x: x[2] > x[3],
        ],
    ]
    sizes = [6, 5, 4]

    # solve each level, concatenate to form the key
    key = b''.join(solve_level(n, cs) for n, cs in zip(sizes, constraints))

    # XOR‐decode and print the flag!
    flag = xor(ciph, key)
    print(flag.decode())

if __name__ == '__main__':
    main()
