#!/usr/bin/env python3
"""
Optimized solver for a 3D maze challenge using pwntools to read memory from a remote ELF.
The maze is represented as a 20×20×20 grid of cells, each 0x10 bytes in size. Each cell
contains four 32-bit integers; the fourth integer indicates the cell type:
    0 = START, 1 = OPEN, 2 = CLOSED, 3 = FINISH.

This script performs a depth-first search (DFS) starting from (0, 0, 0) to find a path
to the FINISH cell, then translates that path into movement commands (L/R/F/B/U/D)
and sends them to the remote service.
"""

import struct
from collections import deque
from pwn import ELF, remote

# Maze dimensions and memory constants
MAZE_SIZE = 20         # Number of cells along each axis (x, y, z)
CELL_SIZE = 0x10       # Size of each cell in bytes

# Cell type constants
START = 0
OPEN = 1
CLOSED = 2
FINISH = 3

# Load the local ELF to read the maze memory
e = ELF("./tunnel", checksec=False)


def read_cell(addr):
    """
    Read four 32-bit integers from the given memory address in the ELF.
    
    Args:
        addr (int): The byte address in memory to read from.
    
    Returns:
        tuple[int, int, int, int]: The unpacked 4 integers from the cell.
    """
    data = e.read(addr, CELL_SIZE)
    return struct.unpack("IIII", data)


def read_coord(coord):
    """
    Compute the memory address of a cell at the given (x, y, z) coordinate
    and read its contents.
    
    Args:
        coord (tuple[int, int, int]): The (x, y, z) coordinates of the target cell.
    
    Returns:
        tuple[int, int, int, int]: The unpacked cell data at that coordinate.
    """
    x, y, z = coord
    base = e.sym["maze"]
    offset = (
        x * MAZE_SIZE * MAZE_SIZE * CELL_SIZE
        + y * MAZE_SIZE * CELL_SIZE
        + z * CELL_SIZE
    )
    return read_cell(base + offset)


def get_adj(pos):
    """
    Generate all valid orthogonal neighbors (up to 6) of the current position in the cube.
    
    Args:
        pos (tuple[int, int, int]): The current (x, y, z) position.
    
    Returns:
        list[tuple[int, int, int]]: List of neighboring coordinates within bounds.
    """
    x, y, z = pos
    neighbors = []
    # Check each axis for valid moves without leaving the cube boundary [0, MAZE_SIZE)
    if x > 0:
        neighbors.append((x - 1, y, z))
    if x + 1 < MAZE_SIZE:
        neighbors.append((x + 1, y, z))
    if y > 0:
        neighbors.append((x, y - 1, z))
    if y + 1 < MAZE_SIZE:
        neighbors.append((x, y + 1, z))
    if z > 0:
        neighbors.append((x, y, z - 1))
    if z + 1 < MAZE_SIZE:
        neighbors.append((x, y, z + 1))
    return neighbors


def solve():
    """
    Perform an iterative depth-first search (DFS) from the START cell (0,0,0) to locate the FINISH cell.
    The maze layout is read directly from the ELF's memory region 'maze'.

    Returns:
        list[tuple[int, int, int]]: The sequence of coordinates from START to FINISH, inclusive.
                                   If no path is found, raises a RuntimeError.
    """
    start = (0, 0, 0)
    # Stack holds tuples of (current_position, path_list_up_to_current)
    stack = [(start, [start])]
    visited = {start}

    while stack:
        pos, path = stack.pop()
        for nbr in get_adj(pos):
            if nbr in visited:
                continue
            _, _, _, cell_type = read_coord(nbr)
            if cell_type == FINISH:
                # Found the finish: return the path plus this final step
                return path + [nbr]
            if cell_type == OPEN:
                visited.add(nbr)
                stack.append((nbr, path + [nbr]))

    raise RuntimeError("No path to FINISH found")


def coords_to_commands(path):
    """
    Translate a list of 3D coordinates into movement commands.
    
    Mapping:
        - X increases → "R" (right)
        - X decreases → "L" (left)
        - Y increases → "F" (forward)
        - Y decreases → "B" (backward)
        - Z increases → "U" (up)
        - Z decreases → "D" (down)
    
    Args:
        path (list[tuple[int, int, int]]): Sequence of coordinates from START to FINISH.
    
    Returns:
        str: A string of single-letter commands corresponding to each step.
    """
    moves = []
    for prev, cur in zip(path, path[1:]):
        dx, dy, dz = cur[0] - prev[0], cur[1] - prev[1], cur[2] - prev[2]
        if dx > 0:
            moves.append("R")
        elif dx < 0:
            moves.append("L")
        elif dy > 0:
            moves.append("F")
        elif dy < 0:
            moves.append("B")
        elif dz > 0:
            moves.append("U")
        elif dz < 0:
            moves.append("D")
    return "".join(moves)


def main():
    """
    Main execution routine: solve the maze, convert to commands, connect to the remote service,
    send each command in order, and print the final response.
    """
    # Find the path from START to FINISH
    path = solve()

    # Convert the coordinate path to a sequence of single-letter commands
    solution = coords_to_commands(path)

    # Connect to the remote service hosting the tunnel challenge
    r = remote("94.237.60.55", 34894)

    # Send each command when prompted with a "?" from the remote
    for cmd in solution:
        r.sendlineafter(b"? ", cmd.encode())

    # Receive and print the final line of output (flag or success message)
    # The first line is usually a prompt or echo, so we grab the second line
    print(r.recvlines(2)[1].decode())


if __name__ == "__main__":
    main()
