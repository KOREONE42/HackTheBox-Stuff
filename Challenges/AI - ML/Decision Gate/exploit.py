#!/usr/bin/env python3
import joblib
import numpy as np
import socket

# 1. Load the trained decision tree model
model = joblib.load("tree_model.joblib")

# 2. Identify the index of the "UNLOCK_FLAG_PATH" class
target_class = "UNLOCK_FLAG_PATH"
if target_class not in model.classes_:
    raise ValueError(f"{target_class!r} not found in model.classes_: {model.classes_}")
target_idx = list(model.classes_).index(target_class)

# 3. Extract the raw tree structure
tree = model.tree_

# 4. Find a leaf node predicting our target class
leaf_nodes = [
    node for node in range(tree.node_count)
    if tree.children_left[node] == -1
    and np.argmax(tree.value[node][0]) == target_idx
]
if not leaf_nodes:
    raise RuntimeError("No leaf predicts UNLOCK_FLAG_PATH")
leaf = leaf_nodes[0]

# 5. Walk back up the tree to collect (feature, threshold, went_left)
parent = {}
for i in range(tree.node_count):
    left = tree.children_left[i]
    right = tree.children_right[i]
    if left != -1:
        parent[left] = (i, True)
    if right != -1:
        parent[right] = (i, False)

path_conditions = []
node = leaf
while node in parent:
    p, went_left = parent[node]
    feat = tree.feature[p]
    thresh = tree.threshold[p]
    path_conditions.append((feat, thresh, went_left))
    node = p
path_conditions.reverse()

# 6. Build a synthetic input x that satisfies every condition
n_features = model.n_features_in_
x = np.zeros(n_features, dtype=float)
epsilon = 1e-6

for feat, thresh, went_left in path_conditions:
    if went_left:
        x[feat] = thresh - epsilon
    else:
        x[feat] = thresh + epsilon

# 7. Double-check
pred = model.predict(x.reshape(1, -1))[0]
assert pred == target_class, f"Expected {target_class}, got {pred!r}"

print("Constructed vector:", x.tolist())

# 8. Send to remote service using comma-separated floats
HOST = "94.237.60.55"
PORT = 57873
with socket.create_connection((HOST, PORT), timeout=10) as s:
    # <-- key change: commas instead of spaces
    payload = ",".join(f"{v:.6f}" for v in x) + "\n"
    s.sendall(payload.encode("ascii"))

    resp = b""
    while not resp.endswith(b"\n"):
        chunk = s.recv(4096)
        if not chunk:
            break
        resp += chunk

print("Remote response:")
print(resp.decode("utf-8", errors="ignore"))
