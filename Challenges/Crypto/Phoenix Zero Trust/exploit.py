#!/usr/bin/env python3
from pwn import remote
from randcrack import RandCrack
import random
import logging

def connect(host: str, port: int):
    """
    Establish a remote connection to the Overwatch service.

    :param host: The hostname or IP address of the service.
    :param port: The port number of the service.
    :return: A pwntools remote connection object.
    """
    logging.info(f"Connecting to {host}:{port}")
    return remote(host, port)

def fetch_challenges(conn, rounds: int = 10, extract_words: int = 64) -> list[int]:
    """
    Request challenge values from the service and decompose each into 32-bit words.

    :param conn: An active pwntools remote connection.
    :param rounds: Number of challenge rounds to perform.
    :param extract_words: Number of 32-bit words to extract per round.
    :return: A flat list of 32-bit unsigned integers observed from the service.
    """
    outputs = []
    for i in range(rounds):
        conn.sendline(b'2')            # Select action: get challenge
        conn.sendline(b'overwatch')    # Provide user name
        conn.sendline(b'1')            # Choose option 1
        conn.sendline(b'1')            # Confirm

        conn.recvuntil(b'Challenge c: ')
        c_val = int(conn.recvline().strip()) - 1

        # Decompose the challenge into 32-bit words (little-endian)
        for _ in range(extract_words):
            outputs.append(c_val & 0xFFFFFFFF)
            c_val >>= 32
    return outputs

def recover_state(outputs: list[int]) -> RandCrack:
    """
    Recover the MT19937 internal state using partial 32-bit output leaks.

    :param outputs: A list of 32-bit outputs from the service.
    :return: A RandCrack instance seeded to the server's RNG state.
    """
    rc = RandCrack()
    # Feed the first 624 values to reconstruct the MT19937 state
    for word in outputs[:624]:
        rc.submit(word)
    # Advance the RandCrack internal pointer to align with server state
    for word in outputs[624:]:
        rc.predict_getrandbits(32)
    return rc

def compute_response(rc: RandCrack, pubkey: int, p: int, g: int = 2) -> tuple[int, int]:
    """
    Compute the login parameters (u, z) using the predicted challenge and DH parameters.

    :param rc: A RandCrack instance aligned with server RNG.
    :param pubkey: The server-provided public key (h = g^x mod p).
    :param p: The prime modulus used by the service.
    :param g: The generator used by the service (default: 2).
    :return: A tuple of integers (u, z) to send for authentication.
    """
    # Predict next challenge value c in range [1, p-1]
    next_c = rc.predict_randint(1, p - 1)
    # Choose a random secret z
    z = random.randint(1, (p - 1) // 2 - 1)
    # Compute u = g^z * h^{-c} mod p
    h_c_inv = pow(pow(pubkey, next_c, p), -1, p)
    u = (pow(g, z, p) * h_c_inv) % p
    return u, z

def main():
    """
    Main exploit logic: connect, recover RNG state, predict challenge,
    and authenticate to the service.
    """
    logging.basicConfig(level=logging.INFO)

    # Service parameters
    HOST = '94.237.121.185'
    PORT = 36099
    P = 0xFFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B423861285C97FFFFFFFFFFFFFFFF
    G = 2

    conn = connect(HOST, PORT)
    outputs = fetch_challenges(conn)
    rc = recover_state(outputs)

    # Request the server's public key for authentication
    conn.sendline(b'3')
    conn.recvuntil(b'overwatch: ')
    pubkey = int(conn.recvline().strip())

    # Compute authentication parameters
    u, z = compute_response(rc, pubkey, P, G)

    # Perform login using predicted values
    conn.sendline(b'2')
    conn.sendline(b'overwatch')
    conn.sendline(str(u).encode())
    conn.sendline(str(z).encode())

    # Switch to interactive mode to receive the flag or prompt
    conn.interactive()

if __name__ == '__main__':
    main()
