import os
from Crypto.Util.Padding import pad, unpad
from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b
from enum import Enum


class Mode(Enum):
    """
    Supported cipher modes.
    """
    ECB = 1  # Electronic Codebook
    CBC = 2  # Cipher Block Chaining


class Cipher:
    """
    Implementation of the Tiny Encryption Algorithm (TEA) in ECB and CBC modes.

    Attributes:
        BLOCK_SIZE (int): Block size in bits (64 for TEA).
        KEY (list[int]): List of four 32-bit subkeys derived from the user-provided key.
        DELTA (int): TEA constant delta for key schedule.
        mode (Mode): Encryption mode (ECB or CBC).
        iv (bytes | None): Initialization vector for CBC mode.
        _mask (int): Mask for 32-bit truncation.
    """

    BLOCK_SIZE = 64  # bits
    ROUNDS = 32
    DELTA = 0x9E3779B9
    _mask = (1 << (BLOCK_SIZE // 2)) - 1

    def __init__(self, key: bytes, iv: bytes = None, mode: Mode = Mode.ECB) -> None:
        """
        Initialize the cipher with a 16-byte key and optional IV for CBC.

        Args:
            key (bytes): 16-byte encryption key.
            iv (bytes, optional): 8-byte initialization vector for CBC mode.
            mode (Mode, optional): Cipher mode (ECB or CBC). Defaults to ECB.

        Raises:
            ValueError: If key or IV lengths are invalid.
        """
        if len(key) != 16:
            raise ValueError("Key must be 16 bytes long")
        if mode == Mode.CBC and (iv is None or len(iv) != self.BLOCK_SIZE // 8):
            raise ValueError(f"IV must be {self.BLOCK_SIZE//8} bytes for CBC mode")

        # Split key into four 32-bit integers
        self.KEY = [b2l(key[i : i + 4]) for i in range(0, len(key), 4)]
        self.iv = iv
        self.mode = mode

    def _encrypt_block(self, block: bytes) -> bytes:
        """
        Encrypt a single 64-bit block using TEA.

        Args:
            block (bytes): 8-byte plaintext block.
        Returns:
            bytes: 8-byte ciphertext block.
        """
        v0, v1 = b2l(block[:4]), b2l(block[4:])
        sum_ = 0
        k0, k1, k2, k3 = self.KEY

        for _ in range(self.ROUNDS):
            sum_ = (sum_ + self.DELTA) & 0xFFFFFFFF
            v0 = (v0 + (((v1 << 4) + k0) ^ (v1 + sum_) ^ ((v1 >> 5) + k1))) & 0xFFFFFFFF
            v1 = (v1 + (((v0 << 4) + k2) ^ (v0 + sum_) ^ ((v0 >> 5) + k3))) & 0xFFFFFFFF

        encrypted = (v0 << 32) | v1
        return l2b(encrypted, 8)

    def _decrypt_block(self, block: bytes) -> bytes:
        """
        Decrypt a single 64-bit block using TEA.

        Args:
            block (bytes): 8-byte ciphertext block.
        Returns:
            bytes: 8-byte plaintext block.
        """
        v0, v1 = b2l(block[:4]), b2l(block[4:])
        sum_ = (self.DELTA * self.ROUNDS) & 0xFFFFFFFF
        k0, k1, k2, k3 = self.KEY

        for _ in range(self.ROUNDS):
            v1 = (v1 - (((v0 << 4) + k2) ^ (v0 + sum_) ^ ((v0 >> 5) + k3))) & 0xFFFFFFFF
            v0 = (v0 - (((v1 << 4) + k0) ^ (v1 + sum_) ^ ((v1 >> 5) + k1))) & 0xFFFFFFFF
            sum_ = (sum_ - self.DELTA) & 0xFFFFFFFF

        decrypted = (v0 << 32) | v1
        return l2b(decrypted, 8)

    def encrypt(self, data: bytes) -> bytes:
        """
        Encrypt data in the selected mode, applying PKCS7 padding and optional CBC chaining.

        Args:
            data (bytes): Plaintext data of arbitrary length.
        Returns:
            bytes: Ciphertext.
        """
        block_size_bytes = self.BLOCK_SIZE // 8
        padded = pad(data, block_size_bytes)
        blocks = [padded[i : i + block_size_bytes] for i in range(0, len(padded), block_size_bytes)]

        ct_blocks = []
        prev = self.iv if self.mode == Mode.CBC else None

        for block in blocks:
            if self.mode == Mode.CBC:
                block = bytes(a ^ b for a, b in zip(block, prev))
            encrypted = self._encrypt_block(block)
            ct_blocks.append(encrypted)
            if self.mode == Mode.CBC:
                prev = encrypted

        return b"".join(ct_blocks)

    def decrypt(self, data: bytes) -> bytes:
        """
        Decrypt data in the selected mode, removing PKCS7 padding and applying CBC unchaining if needed.

        Args:
            data (bytes): Ciphertext data.
        Returns:
            bytes: Plaintext.
        """
        block_size_bytes = self.BLOCK_SIZE // 8
        blocks = [data[i : i + block_size_bytes] for i in range(0, len(data), block_size_bytes)]

        pt_blocks = []
        prev = self.iv if self.mode == Mode.CBC else None

        for block in blocks:
            decrypted = self._decrypt_block(block)
            if self.mode == Mode.CBC:
                decrypted = bytes(a ^ b for a, b in zip(decrypted, prev))
                prev = block
            pt_blocks.append(decrypted)

        plaintext = b"".join(pt_blocks)
        return unpad(plaintext, block_size_bytes)


if __name__ == "__main__":
    # Example usage: read hex from file and decrypt
    with open('output.txt', 'r') as f:
        lines = f.read().splitlines()
    key_hex = lines[0].split(':', 1)[1].strip()
    ct_hex = lines[1].split(':', 1)[1].strip()
    key = bytes.fromhex(key_hex)
    ciphertext = bytes.fromhex(ct_hex)

    cipher = Cipher(key, mode=Mode.ECB)
    decrypted = cipher.decrypt(ciphertext)
    print("Decrypted Flag:", decrypted.decode())
