#!/usr/bin/env sage
from ast import literal_eval
from Crypto.PublicKey import RSA
from sage.all import Matrix, QQ, Integer

# 1) Load inputs
with open("pubkey.pem", "rt") as pk:
    key = RSA.import_key(pk.read())
with open("output.txt", "rt") as o:
    txt = o.read()
    R = literal_eval(txt.split("R = ")[1])

n = Integer(key.n)

# 2) Compute parameters
k = -(-n.bit_length() // 8)
B = 2 ** (8 * (k - 2))
W = 3 * B - 1
H = 2 * B + B // 2

# 3) Build the lattice basis
# — first |R| rows: a single n on the diagonal
rows = [
    [0]*i + [n] + [0]*((len(R)-i) + 1)
    for i in range(len(R))
]
# — the “R‑row”
t = list(sorted(R))
rows.append(t + [W / n, 0])
# — the “C‑row”
a = [H]*len(R)
rows.append(a + [0, W])

# sanity check: every row must have len(R)+2 columns
assert all(len(row) == len(R)+2 for row in rows)

M = Matrix(QQ, rows)

# 4) LLL‑reduce and extract the short vector
L = M.LLL()
row = L[-1]
assert abs(row[-1]) == W

# 5) Recover m for each oracle query and test padding
for i in range(len(R)):
    m_i = (abs(row[i]) + H) * pow(R[i], -1, n) % n
    plaintext = m_i.to_bytes(k, "big")
    if plaintext.startswith(b"\x00\x02") and b"HTB{" in plaintext:
        flag = plaintext.split(b"\x00")[-1].decode()
        print("=== FLAG:", flag)
        break
