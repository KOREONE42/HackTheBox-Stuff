from Crypto.Util.number import long_to_bytes
from pwn import remote


def oracle_query(proc, ct):
    """Send ciphertext to the oracle and return the decrypted response."""
    proc.sendline(b"2")
    proc.readuntil(b"nt: ")
    proc.sendline(long_to_bytes(ct).hex().encode())
    proc.readuntil(b"er: ")
    return int(proc.readline().strip())


def is_prime(n, k=5):
    """Perform Miller-Rabin primality test to check if number n is prime."""
    from random import randint
    if n < 2:
        return False
    for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]:
        if n % p == 0:
            return n == p
    s, d = 0, n - 1
    while d % 2 == 0:
        s, d = s + 1, d // 2
    for _ in range(k):
        x = pow(randint(2, n - 1), d, n)
        if x in (1, n - 1):
            continue
        for _ in range(s - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True


def get_initial_sequence(proc, sequence_len, M):
    """Retrieve the initial sequence from the oracle."""
    return [oracle_query(proc, 1) for _ in range(sequence_len)]


def verify_sequence(proc, x, M):
    """Verify if the predicted sequence matches oracle responses."""
    for _ in range(10):
        x = pow(x, 2, M)
        expected = 0 if x % 2 else 1
        if expected != oracle_query(proc, 1):
            return False
    return True


# Main exploit logic
def main():
    proc = remote("94.237.50.221", 41721)

    e = 65537
    sequence_len = 30

    # Read modulus M
    proc.readuntil(b"M = ")
    M = int(proc.readline().strip())

    # Retrieve encrypted flag and modulus n
    proc.sendline(b"1")
    proc.readuntil(b"n = ")
    n = int(proc.readline().strip())
    proc.readuntil(b"led: ")
    flag = int(proc.readline().strip())

    # Retrieve known initial sequence from oracle
    known_sequence = get_initial_sequence(proc, sequence_len, M)

    # Brute-force initial state x0 of the PRG
    x0 = None
    for i in range(2, 2**15):
        if not is_prime(i):
            continue

        x = i
        generated_seq = [0 if pow(x := pow(x, 2, M), 1, 2) else 1 for _ in range(sequence_len)]

        if generated_seq == known_sequence:
            x0 = i
            print(f"Recovered initial state x0: {x0}")
            break

    if x0 is None:
        print("Failed to recover initial state")
        return

    # Update PRG after initial sequence extraction
    for _ in range(sequence_len):
        x0 = pow(x0, 2, M)

    if not verify_sequence(proc, x0, M):
        print("Sequence verification failed")
        return

    print("Sequence verified successfully")

    # Update PRG post verification
    for _ in range(10):
        x0 = pow(x0, 2, M)

    # Binary search decryption of flag
    low, high = 0, n

    for i in range(1, 1450):
        print(f"Iteration: {i}")

        x0 = pow(x0, 2, M)
        is_LSB = (x0 % 2 == 0)

        exponent_shift = 0 if is_LSB else 1
        ct = (flag * pow(2, e * (i - exponent_shift), n)) % n

        response = oracle_query(proc, ct)
        if response == 0:
            high = (low + high) // 2
        else:
            low = (low + high) // 2

        if high == low:
            break

    recovered_plaintext = long_to_bytes(low)
    print(recovered_plaintext)


if __name__ == "__main__":
    main()