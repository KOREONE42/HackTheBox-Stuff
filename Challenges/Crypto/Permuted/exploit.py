#!/usr/bin/env python3
import sys
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.Util.number import long_to_bytes
from hashlib import sha256
from math import gcd

# -----------------------------------------------------------------------------
# Permutation helpers
# -----------------------------------------------------------------------------

def compose(p, q):
    """
    Return the permutation p ∘ q on the same domain:
    (p ∘ q)(i) = p[q[i]]
    """
    return [p[q[i]] for i in range(len(p))]

def perm_pow(p, exponent):
    """
    Fast exponentiation of a permutation p by integer exponent:
    computes p**exponent = p ∘ p ∘ … (exponent times).
    """
    n = len(p)
    result = list(range(n))  # identity
    base = p.copy()
    e = exponent
    while e > 0:
        if e & 1:
            result = compose(base, result)
        base = compose(base, base)
        e >>= 1
    return result

def cycle_decomposition(p):
    """
    Decompose permutation p (as a list) into disjoint cycles.
    Returns a list of cycles, each cycle is a list of its elements.
    """
    n = len(p)
    seen = [False]*n
    cycles = []
    for i in range(n):
        if not seen[i]:
            cyc = []
            cur = i
            while not seen[cur]:
                seen[cur] = True
                cyc.append(cur)
                cur = p[cur]
            if len(cyc) > 0:
                cycles.append(cyc)
    return cycles

# -----------------------------------------------------------------------------
# Chinese remainder (incremental)
# -----------------------------------------------------------------------------

def crt(congruences):
    """
    Solve a system of congruences x ≡ ai (mod mi)
    congruences = [(a1, m1), (a2, m2), ...]
    Returns (x, M) where x is the unique solution modulo M = lcm(mi).
    """
    x, m = 0, 1
    for ai, mi in congruences:
        g = gcd(m, mi)
        if (ai - x) % g:
            raise ValueError(f"No solution for x ≡ {ai} mod {mi}")
        # combine:
        m1 = m // g
        mi1 = mi // g
        # find inverse of m1 mod mi1
        inv = pow(m1, -1, mi1)
        k = ((ai - x) // g * inv) % mi1
        x = x + m * k
        m = m * mi1
        x %= m
    return x, m

# -----------------------------------------------------------------------------
# Solve discrete log in the permutation group: find a such that A = g**a
# -----------------------------------------------------------------------------

def solve_exponent(g, A):
    """
    Given base permutation g and public permutation A = g**a,
    recover the integer a via cycle-by-cycle DLOG + CRT.
    """
    print(f"[+] Decomposing g into cycles…")
    cycles = cycle_decomposition(g)
    print(f"    → found {len(cycles)} cycles; "
          f"example lengths:", [len(c) for c in cycles[:5]], "…")

    congruences = []
    for cyc in cycles:
        L = len(cyc)
        if L == 1:
            continue
        # On this cycle, g**a shifts each element forward by a mod L.
        # Pick representative x = cyc[0], then A[x] = cyc[(0 + a) % L].
        target = A[cyc[0]]
        # find shift j s.t. cyc[j] == target
        j = cyc.index(target)
        congruences.append((j, L))
    print(f"[+] Built {len(congruences)} congruences; running CRT…")
    a, mod = crt(congruences)
    print(f"    → a mod lcm(cycle lengths) = {a} (mod {mod})")
    return a

# -----------------------------------------------------------------------------
# Main routine
# -----------------------------------------------------------------------------

def main():
    # Load the three lists g, A, B and the ciphertext c from output.txt
    ns = {}
    with open('output.txt','r') as f:
        code = f.read()
    exec(code, ns)

    g = ns['g']
    A = ns['A']
    B = ns['B']
    c = ns['c']

    print(f"[+] Loaded permutations of length {len(g)}")
    # Step 1: recover a such that A = g**a
    a = solve_exponent(g, A)
    print(f"[+] Recovered exponent a = {a}\n")

    # Step 2: compute the shared secret permutation C = B**a
    print(f"[+] Computing shared secret permutation C = B**a …")
    C = perm_pow(B, a)

    # Step 3: key derivation
    sec_tuple = tuple(C)
    sec_int   = abs(hash(sec_tuple))
    sec_bytes = long_to_bytes(sec_int)
    key       = sha256(sec_bytes).digest()[16:32]
    iv        = b'\xfb\x1d]\xbc\r\xa3\x91\x1cvV#\x13\xd8z\xb4\x16'

    print(f"[+] Derived key (hex): {key.hex()}")
    print(f"[+] IV (hex):         {iv.hex()}\n")

    # Step 4: AES‐CBC decrypt and unpad
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plain = unpad(cipher.decrypt(c), 16)
    print(f"FLAG: {plain.decode()!r}")

if __name__ == '__main__':
    main()
