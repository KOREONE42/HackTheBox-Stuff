#!/usr/bin/env python3
import math
from typing import Tuple


def read_parameters(filename: str) -> Tuple[int, int, int, int, int, int, int]:
    """
    Read the seven integer parameters from a file.

    The file must contain exactly seven lines, each an integer in this order:
      n1, c1, c2, n2, c3, c4, L

    :param filename: Path to the input file
    :return: A tuple (n1, c1, c2, n2, c3, c4, L)
    :raises ValueError: If the file does not contain exactly seven lines
    """
    with open(filename, 'r') as f:
        values = [int(line.strip()) for line in f]
    if len(values) != 7:
        raise ValueError(f"Expected 7 parameters, got {len(values)}")
    return tuple(values)


def compute_C(n1: int, n2: int) -> int:
    """
    Compute the shared constant C = gcd(n1 - 4, n2 - 4) // 3.

    :param n1: First modulus
    :param n2: Second modulus
    :return: The integer C
    """
    return math.gcd(n1 - 4, n2 - 4) // 3


def compute_message(
    n: int,
    c_low: int,
    c_high: int,
    K: int,
    C: int
) -> int:
    """
    Recover one plaintext block (as an integer) from its ciphertext pieces.

    The steps are:
      1. Construct P by repeating hex(K)[2:] exactly K times.
      2. Compute X = (c_high - P^2 - P*C) * inv_mod(256^K, n) mod n.
      3. Compute m = (X - 256^K * c_low) * inv_mod(2P + C - C·256^K, n) mod n.

    :param n: The RSA modulus
    :param c_low: Ciphertext component c1 (or c3)
    :param c_high: Ciphertext component c2 (or c4)
    :param K: Block‐size parameter (depends on L)
    :param C: Shared constant from compute_C
    :return: The recovered block as an integer
    """
    # Build P = int(hex(K)[2:] * K, 16)
    hex_str = hex(K)[2:]
    P = int(hex_str * K, 16)

    # Compute modular inverse of 256^K
    inv_256K = pow(256**K, -1, n)

    # Intermediate value X
    X = (c_high - P * P - P * C) * inv_256K % n

    # Denominator for the final inversion
    denom = 2 * P + C - C * 256**K

    # Recover message block
    m = (X - (256**K) * c_low) * pow(denom, -1, n) % n
    return m


def decode_messages(filename: str) -> str:
    """
    Orchestrate reading parameters, recovering both message blocks, and decoding to ASCII.

    :param filename: Path to the input file
    :return: The full decoded plaintext
    """
    n1, c1, c2, n2, c3, c4, L = read_parameters(filename)
    C = compute_C(n1, n2)

    # Two block‐size values based on L
    K1 = 256 - math.floor(L / 2)
    K2 = 256 - math.ceil(L / 2)

    # Recover each block
    m1 = compute_message(n1, c1, c2, K1, C)
    m2 = compute_message(n2, c3, c4, K2, C)

    # Concatenate their hex representations and decode
    hex_combined = hex(m1)[2:] + hex(m2)[2:]
    return bytes.fromhex(hex_combined).decode()


def main():
    """Read 'out.txt', decode the two-message payload, and print the plaintext."""
    plaintext = decode_messages('out.txt')
    print(plaintext)


if __name__ == '__main__':
    main()
