#!/usr/bin/env sage
from sage.all import *
import os, glob
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

# ── 0. Point at the directory with all your .vlny… samples ────────────────
REPO_PATH = '/home/kore/Downloads/crypto_curveware/'

# ── 1. Gather R, S and the 40‑bit leaks ────────────────────────────────────
LEAKS = []
R     = []
S     = []

for root, dirs, files in os.walk(REPO_PATH):
    for f in files:
        if '.vlny' not in f:
            continue
        # read signature
        data = open(os.path.join(root, f), 'rb').read()
        sig  = data[:0x40]  # first 64 bytes = r||s
        R.append(int(sig[0x00:0x20].hex(), 16))
        S.append(int(sig[0x20:0x40].hex(), 16))
        # parse the 10 hex chars after ".vlny"
        leak = int(f.split('.vlny', 1)[1], 16)
        LEAKS.append(leak)

m = len(LEAKS)
print(f"Found {m} samples")

# ── 2. Curve order and leak modulus ────────────────────────────────────────
n  = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551
F  = GF(n)
LS = 16**10     # 2^40

# ── 3. Build the 3×3 Sage QQ‑matrix and run LLL ───────────────────────────
#    (this is the single‑sample embedding)
B   = next_prime(n)
kW  = next_prime(2**n.bit_length() // LS)
FLS = F(LS)

M = block_matrix(QQ, [
    [ n / kW ],
    [ (matrix(S) * FLS**(-1)) / kW ],
    [ ((matrix(R) - matrix(LEAKS)) * FLS**(-1)) / kW ],
])

print("Running LLL…")
for row in M.LLL():
    if row[0] != 0:
        # recover k0 and then the private key x
        k0 = LS * int(abs(row[0] * kW)) + LEAKS[0]
        x  = pow(S[0], -1, n) * (k0 - R[0]) % n
        break

print(f"Recovered x = {x:x}")
key = x.to_bytes(32, 'big')

# ── 4. Decrypt the flag ────────────────────────────────────────────────────
# the flag file is named flag.txt.vlny<…>
flag_path = glob.glob(f"{REPO_PATH}/business-ctf-2025-dev/crypto/curveware/flag.txt.vlny*")[0]
data      = open(flag_path, 'rb').read()

# layout: [0x00–0x40) = sig, [0x40…-0x10) = ciphertext, [-0x10…end) = IV
enc_flag  = data[0x40:-0x10]
iv        = data[-0x10:]

cipher = AES.new(key, AES.MODE_CBC, iv)
flag   = unpad(cipher.decrypt(enc_flag), 16).decode()
print(f"Flag: {flag}")
