#!/usr/bin/env python3
"""
Optimized client for retrieving a one-time password via fast Turbonacci sequence
modular arithmetic and decrypting a remote flag.
"""
from pwn import remote, log
from typing import Tuple
import re


def legendre_symbol(a: int, p: int) -> int:
    """
    Compute the Legendre symbol (a|p) for prime p.

    Returns:
        1 if a is a quadratic residue modulo p (and a % p != 0),
       -1 if a is a non-residue,
        0 if a is divisible by p.
    """
    ls = pow(a, (p - 1) >> 1, p)
    if ls == p - 1:
        return -1
    return ls


def modular_sqrt(n: int, p: int) -> int:
    """
    Tonelli–Shanks algorithm to find a square root of n modulo prime p.

    Args:
        n: quadratic residue modulo p
        p: odd prime

    Returns:
        One of the square roots r such that r^2 ≡ n (mod p).

    Raises:
        AssertionError if n is not a quadratic residue.
    """
    assert legendre_symbol(n, p) == 1, f"No square root exists for {n} mod {p}"

    # Factor p-1 as q * 2^s with q odd
    q, s = p - 1, 0
    while not q & 1:
        q >>= 1
        s += 1

    # If p ≡ 3 (mod 4), shortcut available
    if s == 1:
        return pow(n, (p + 1) >> 2, p)

    # Find quadratic non-residue z
    z = 2
    while legendre_symbol(z, p) != -1:
        z += 1

    # Initialize variables
    c = pow(z, q, p)
    r = pow(n, (q + 1) >> 1, p)
    t = pow(n, q, p)
    m = s

    # Iterate until t ≡ 1 (mod p)
    while t != 1:
        # Find lowest i (0 < i < m) with t^(2^i) ≡ 1
        t2 = t
        for i in range(1, m):
            t2 = pow(t2, 2, p)
            if t2 == 1:
                break

        # Update values
        b = pow(c, 1 << (m - i - 1), p)
        r = (r * b) % p
        c = pow(b, 2, p)
        t = (t * c) % p
        m = i
    return r


def fast_turbonacci(n: int, p: int, b: int, c: int) -> int:
    """
    Compute the nth term of the recurrence X_k = b*X_{k-1} + c*X_{k-2} modulo p
    using the closed-form (Binet-like) formula with modular arithmetic.

    Args:
        n: index of term to compute
        p: prime modulus
        b, c: recurrence coefficients

    Returns:
        X_n modulo p
    """
    # Compute discriminant and its sqrt mod p
    disc = (b * b + 4 * c) % p
    sqrt_disc = modular_sqrt(disc, p)

    inv2 = pow(2, -1, p)
    r1 = (b + sqrt_disc) * inv2 % p
    r2 = (b - sqrt_disc) * inv2 % p

    # Use modular exponentiation
    num = (pow(r1, n, p) - pow(r2, n, p)) % p
    den = (r1 - r2) % p
    return num * pow(den, -1, p) % p


def interact_and_solve(host: str, port: int) -> None:
    """
    Connect to remote service to obtain parameters, compute OTP,
    and decrypt the flag.

    Args:
        host: remote hostname or IP
        port: remote port

    This function logs each step and prints the final flag.
    """
    io = remote(host, port)
    try:
        log.info("Reading parameters from server...")
        # Helper to receive and parse an integer parameter, ignoring extra text
        def recv_int(marker: bytes) -> int:
            io.recvuntil(marker)
            line = io.recvline().decode().strip()
            # take the first token, which should be the integer
            token = line.split()[0]
            return int(token)

        p = recv_int(b'p = ')
        b = recv_int(b'b = ')
        c = recv_int(b'c = ')
        nonce = recv_int(b'nonce = ')
        log.info(f"Parameters: p={p}, b={b}, c={c}, nonce={nonce}")

        # Compute one-time password
        otp = fast_turbonacci(nonce, p, b, c)
        log.info(f"Computed OTP: {otp}")
        io.sendlineafter(b'OTP: ', str(otp).encode())

        # Request encrypted flag
        io.sendlineafter(b'> ', b'1')
        io.recvuntil(b'ct = ')
        flag_enc = int(io.recvline().strip())
        log.info(f"Encrypted flag: {flag_enc}")

        # Get encryptions of known plaintexts
        def get_cipher(pt: bytes) -> int:
            io.sendlineafter(b'> ', b'2')
            io.sendlineafter(b'pt = ', pt)
            io.recvuntil(b'ct = ')
            return int(io.recvline().strip())

        ct_a = get_cipher(b'a')
        ct_b = get_cipher(b'b')
        m = (ct_b - ct_a) % p
        inv_m = pow(m, -1, p)

        # Decrypt flag via linear relation
        k = (ord('a') - ct_a * inv_m) % p
        flag = (k + flag_enc * inv_m) % p
        decoded = bytes.fromhex(hex(flag)[2:]).decode()
        log.success(f"Flag: {decoded}")

    except Exception as e:
        log.error(f"Error during interaction: {e}")
    finally:
        io.close()


if __name__ == '__main__':
    HOST = '94.237.57.211'
    PORT = 47721
    interact_and_solve(HOST, PORT)
