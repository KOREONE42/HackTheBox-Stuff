#!/usr/bin/env python3
import requests
import random
import hashlib
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

# ----------------------------------------------------------------
# CHANGE THIS if you need to point somewhere else:
BASE_URL = 'http://94.237.59.38:58517/api'
# ----------------------------------------------------------------

def retrieve_dh_parameters():
    """
    Step 1: POST to /request-session-parameters and parse 'g' and 'p' (both come back as hex strings).
    """
    url = f"{BASE_URL}/request-session-parameters"
    r = requests.post(url)
    r.raise_for_status()
    data = r.json()
    # data looks like { "g": "0x...", "p": "0x..." }
    g = int(data['g'], 16)
    p = int(data['p'], 16)
    return g, p

def establish_secure_session(g, p):
    """
    Step 2: 
    - Generate a random private 'a' in [2, p-2].
    - Compute A = g^a mod p.
    - Send A to /init-session, receive server_public_key.
    - Compute shared_key = (server_public_key^a mod p), then session_key = SHA256(str(shared_key)).digest().
    Returns: session_key (bytes)
    """
    # 2.a: pick a
    a = random.randint(2, p - 2)
    A = pow(g, a, p)

    # 2.b: send client_public_key = A
    url = f"{BASE_URL}/init-session"
    payload = { 'client_public_key': A }
    r = requests.post(url, json=payload)
    r.raise_for_status()
    data = r.json()
    # The server returns something like { "server_public_key": "0x..."} plus status_code / message.
    server_pub_hex = data['server_public_key']
    server_pub = int(server_pub_hex, 16)

    # 2.c: compute shared secret
    shared = pow(server_pub, a, p)
    # Derive AES key = SHA256(str(shared)).digest()
    session_key = hashlib.sha256(str(shared).encode()).digest()
    return session_key

def decrypt_challenge(session_key):
    """
    Step 3:
    - POST to /request-challenge → { "encrypted_challenge": "<base64-string>" }.
    - Base64-decode, split IV = first 16 bytes, ciphertext = rest.
    - AES-CBC-decrypt (unpad) → 24-byte raw challenge.
    """
    url = f"{BASE_URL}/request-challenge"
    r = requests.post(url)
    r.raise_for_status()
    data = r.json()
    b64blob = data['encrypted_challenge']
    raw = base64.b64decode(b64blob)

    iv = raw[:16]
    ciphertext = raw[16:]
    cipher = AES.new(session_key, AES.MODE_CBC, iv)
    plaintext = unpad(cipher.decrypt(ciphertext), 16)
    # According to the PDF, the challenge is exactly 24 bytes (no further structure).
    return plaintext  # bytes

def get_flag(challenge, session_key):
    """
    Step 4:
    - Compute challenge_hash = SHA256(challenge).hexdigest().
    - Build an AES-CBC packet whose payload is b"flag" (padded to 16 bytes), with IV = all‐zeros (16 bytes).
    - Prepend that IV to ciphertext, Base64-encode, send as 'packet_data' along with 'challenge' = challenge_hash.
    - The server’s response is JSON { "packet_data": "<base64-string>" }.
    - Base64-decode, split IV (first 16), ciphertext (rest), decrypt, unpad → ASCII flag.
    """
    url = f"{BASE_URL}/dashboard"
    # 4.a: hash the challenge
    challenge_hash = hashlib.sha256(challenge).hexdigest()

    # 4.b: build AES-CBC encrypted packet with payload b'flag'
    iv_zero = b'\x00' * 16
    cipher = AES.new(session_key, AES.MODE_CBC, iv_zero)
    ciphertext = cipher.encrypt(pad(b'flag', 16))
    packet = iv_zero + ciphertext
    packet_b64 = base64.b64encode(packet).decode()

    payload = {
        'challenge': challenge_hash,
        'packet_data': packet_b64
    }
    r = requests.post(url, json=payload)
    r.raise_for_status()
    data = r.json()
    resp_b64 = data['packet_data']
    raw_resp = base64.b64decode(resp_b64)
    iv_resp = raw_resp[:16]
    ciphertext_resp = raw_resp[16:]
    cipher2 = AES.new(session_key, AES.MODE_CBC, iv_resp)
    plaintext_flag = unpad(cipher2.decrypt(ciphertext_resp), 16)
    return plaintext_flag

def main():
    print("[*] Retrieving DH parameters ...")
    g, p = retrieve_dh_parameters()
    print(f"    → g = {g} (decimal), p = {p} (decimal)")

    print("[*] Establishing secure session ...")
    session_key = establish_secure_session(g, p)
    print("    → Session key (SHA256 of shared secret) established.")

    print("[*] Fetching encrypted challenge ...")
    challenge = decrypt_challenge(session_key)
    print(f"    → Decrypted challenge (hex) = {challenge.hex()}")

    print("[*] Sending challenge response and requesting flag ...")
    flag = get_flag(challenge, session_key)
    try:
        print(f"\n[***] FLAG: {flag.decode()}\n")
    except UnicodeDecodeError:
        # In case the flag contains non-UTF8 bytes (unlikely), print raw repr
        print(f"\n[***] FLAG (raw bytes): {flag!r}\n")

if __name__ == '__main__':
    main()
