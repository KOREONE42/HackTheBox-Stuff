#!/usr/bin/env python3
import sys
import time
import json
import base64
import random
import re
import statistics

import requests
from Crypto.Util.number import long_to_bytes as i2osp
from Crypto.Signature.pss import MGF1
from Crypto.Hash import SHA256 as HF
from pwn import xor

def ceil_div(a, b): return a//b + (a%b>0)
def floor_div(a, b): return a//b

# ———– Manger’s attack steps ———–
def _step_1(pad_oracle, n, e, c):
    f1 = 2
    while not pad_oracle((pow(f1, e, n)*c) % n):
        f1 *= 2
    return f1

def _step_2(pad_oracle, n, e, c, B, f1):
    f2 = (n + B)//B * f1 // 2
    while not pad_oracle((pow(f2, e, n)*c) % n):
        f2 += f1//2
    return f2

def _step_3(pad_oracle, n, e, c, B, f2):
    m_min = ceil_div(n, f2)
    m_max = (n + B)//f2
    it = 0
    while m_min < m_max:
        it += 1
        f = (2*B)//(m_max - m_min)
        i = (f*m_min)//n
        f3 = ceil_div(i*n, m_min)
        if pad_oracle((pow(f3, e, n)*c) % n):
            m_max = (i*n + B)//f3
        else:
            m_min = ceil_div(i*n + B, f3)
        if it % 10 == 0:
            print(f"  [iter {it}] interval = {m_max-m_min}")
    return m_min

def manger(n, e, c, pad_oracle):
    k = ceil_div(n.bit_length(), 8)
    B = 1 << (8*(k-1))
    print("[*] Step 1 → find f1")
    f1 = _step_1(pad_oracle, n, e, c)
    print(f"    f1 = {hex(f1)}")

    print("[*] Step 2 → find f2")
    f2 = _step_2(pad_oracle, n, e, c, B, f1)
    print(f"    f2 = {hex(f2)}")

    print("[*] Step 3 → narrow interval")
    m = _step_3(pad_oracle, n, e, c, B, f2)
    return m

# ———– Calibration (same session) ———–
def calibrate(session, url, c0, k, n, trials=20):
    def measure(c):
        enc = base64.b64encode(i2osp(c, k)).decode()
        t0 = time.time()
        session.post(f"{url}/verify-token", json={"encrypted_token": enc})
        return time.time() - t0

    print("[*] Calibrating timing oracle…")
    valid = [measure(c0) for _ in range(trials)]
    invalid = [measure(random.randrange(1, n)) for _ in range(trials)]
    med_valid = statistics.median(valid)
    med_invalid = statistics.median(invalid)
    thr = (med_valid + med_invalid)/2

    print(f"    valid timings   = {valid!r}")
    print(f"    invalid timings = {invalid!r}")
    print(f"    median(valid)   = {med_valid:.3f}s")
    print(f"    median(invalid) = {med_invalid:.3f}s")
    print(f"    → threshold     = {thr:.3f}s\n")
    return thr

# ———– Main ———–
if __name__ == "__main__":
    URL = "http://" + (sys.argv[1] if len(sys.argv)>1 else "94.237.121.185:51641")
    session = requests.Session()

    # 1) grab modulus & c0
    r = session.get(f"{URL}/")
    payload = json.loads(base64.b64decode(r.cookies['token']))
    n  = int(payload['n'], 16)
    c0 = int(payload['tok'], 16)
    e  = 0x10001
    k  = n.bit_length()//8

    print(f"[*] Server     = {URL}")
    print(f"    n bit-len  = {n.bit_length()}, k = {k}")
    print(f"    c0 (hex)   = {hex(c0)}\n")

    # 2) calibrate
    TH = calibrate(session, URL, c0, k, n, trials=20)

    # 3) define oracle
    def padding_oracle(c):
        enc = base64.b64encode(i2osp(c, k)).decode()
        start = time.time()
        session.post(f"{URL}/verify-token", json={"encrypted_token": enc})
        return (time.time() - start) > TH

    # sanity check
    assert padding_oracle(c0), "c0 should always return True (m < B)"

    # 4) run Manger
    print("[*] Launching Manger’s attack (this can take a few minutes)…")
    m_repr = manger(n, e, c0, padding_oracle)
    EM = i2osp(m_repr, k)
    print(f"[*] Recovered EM = {EM.hex()}\n")

    # 5) OAEP unpad (SHA‑256 & PSS‐MGF1)
    hLen = HF.digest_size
    maskedSeed = EM[1:1+hLen]
    maskedDB   = EM[1+hLen:]
    seedMask   = MGF1(maskedDB, hLen, HF)
    seed       = xor(maskedSeed, seedMask)
    dbMask     = MGF1(seed, k-hLen-1, HF)
    DB         = xor(maskedDB, dbMask)

    # strip PS until 0x01
    PS = DB[hLen:].split(b'\x01')[0]
    M  = DB[hLen+len(PS)+1:]
    pro_token = M.hex()
    print(f"[+] Recovered PRO_TOKEN: {pro_token}\n")

    # 6) fetch admin‑config.xml & decode flag
    r2 = session.post(f"{URL}/download", json={"token": pro_token})
    xml = r2.text
    print("--- admin-config.xml ---\n", xml)
    flag = base64.b64decode(re.search(r"<token>([^<]+)</token>", xml).group(1)).decode()
    print("FLAG:", flag)
