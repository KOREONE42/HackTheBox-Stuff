#!/usr/bin/env sage

import sys
import socket
from Crypto.Util.number import long_to_bytes
from sage.all import EllipticCurve, GF, crt, discrete_log, factor

# Pâ€‘256 parameters
a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
Fp = GF(p)

if len(sys.argv) != 3:
    print("Usage: sage exploit.sage <host> <port>")
    sys.exit(1)

host = sys.argv[1]
port = int(sys.argv[2])

def recv_until(sock, marker):
    data = b''
    while marker not in data:
        chunk = sock.recv(4096)
        if not chunk:
            raise IOError("Connection closed unexpectedly")
        data += chunk
    return data

def get_shared_secret(b):
    E = EllipticCurve(Fp, [a, b])
    G = E.gens()[0]

    sock = socket.create_connection((host, port))
    recv_until(sock, b'Awaiting public key of the client...\n')
    sock.sendall(f"{G[0]} {G[1]}\n".encode())

    data = recv_until(sock, b'Shared secret: ')
    rest = data.split(b'Shared secret: ')[1]
    line = rest.split(b'\n')[0] if b'\n' in rest else rest + sock.recv(4096).split(b'\n')[0]
    sock.close()

    S = E(eval(line.decode()))
    return E.order(), G, factor(E.order()), S

def collect_dlogs(S, G, order, facs, skip_slice, moduli, residues):
    for (pr, exp) in facs[skip_slice[0]:skip_slice[1]]:
        n = pr**exp
        t = order // n
        moduli.append(n)
        # <-- pass operation='+' so Sage knows it's additive
        residues.append(discrete_log(t*S, t*G, operation='+'))

def main():
    moduli = []
    residues = []

    for b_val, skip in [
        (0, (0, -2)),
        (1, (0, -1)),
        (4, (1, -3)),
    ]:
        order, G, facs, S = get_shared_secret(b_val)
        collect_dlogs(S, G, order, facs, skip, moduli, residues)

    x = crt(residues, moduli)
    print(long_to_bytes(x))

if __name__ == '__main__':
    main()
