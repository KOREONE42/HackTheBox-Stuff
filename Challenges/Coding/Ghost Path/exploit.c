#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LOG 20

int N, M, Q;
char *terrain;      // terrain[r*M + c] == '.' or 'X'
int  *region_id;    // region_id[r*M + c] = connected‐component ID in [1..R]
int   R;            // total number of regions

// 8 directions for flood‐fill
int dx8[8] = {-1,1,0,0,-1,1,-1,1};
int dy8[8] = {0,0,-1,1,-1,1,1,-1};

// 4 directions for building adjacency without duplicates
int dx4[4] = {0,1,1,1};
int dy4[4] = {1,0,1,-1};

int *head;          // head[v] = index of first edge out of v, or -1
int *to, *nxt;      // edge lists (size 2*E)
int edge_cnt;

// BFS queue (reused)
int *queue_buf;

// region‐tree data
int *parent, *depth;
int **up;           // up[k][v] = 2^k‐th ancestor of v
char *vis;

// flood‐fill to label each 8‐connected block of '.' or 'X' with a unique ID
void label_regions() {
    R = 0;
    int qr, qc, ql = 0, qr_tail = 0;
    for(int r = 0; r < N; r++) {
        for(int c = 0; c < M; c++) {
            int idx = r*M + c;
            if (region_id[idx] == 0) {
                R++;
                char terr = terrain[idx];
                // start BFS
                queue_buf[0] = idx;
                qr_tail = 1;
                region_id[idx] = R;
                while (ql < qr_tail) {
                    int cur = queue_buf[ql++];
                    int x = cur / M, y = cur % M;
                    for(int d = 0; d < 8; d++) {
                        int nx = x + dx8[d], ny = y + dy8[d];
                        if (nx < 0 || nx >= N || ny < 0 || ny >= M) continue;
                        int nidx = nx*M + ny;
                        if (region_id[nidx] == 0 && terrain[nidx] == terr) {
                            region_id[nidx] = R;
                            queue_buf[qr_tail++] = nidx;
                        }
                    }
                }
                ql = 0;  // reset for next region
            }
        }
    }
}

// count unique region‐adjacencies by scanning only 4 directions
int count_edges() {
    int cnt = 0;
    for(int r = 0; r < N; r++) {
        for(int c = 0; c < M; c++) {
            int u = region_id[r*M + c];
            for(int d = 0; d < 4; d++) {
                int nx = r + dx4[d], ny = c + dy4[d];
                if (nx < 0 || nx >= N || ny < 0 || ny >= M) continue;
                int v = region_id[nx*M + ny];
                if (u != v) cnt++;
            }
        }
    }
    return cnt;
}

// build the undirected region‐adjacency graph
void build_graph() {
    int Euniq = count_edges();
    head = malloc((R+1)*sizeof(int));
    to   = malloc(2*Euniq * sizeof(int));
    nxt  = malloc(2*Euniq * sizeof(int));
    for(int i = 1; i <= R; i++) head[i] = -1;
    edge_cnt = 0;

    for(int r = 0; r < N; r++) {
        for(int c = 0; c < M; c++) {
            int u = region_id[r*M + c];
            for(int d = 0; d < 4; d++) {
                int nx = r + dx4[d], ny = c + dy4[d];
                if (nx < 0 || nx >= N || ny < 0 || ny >= M) continue;
                int v = region_id[nx*M + ny];
                if (u != v) {
                    // u -> v
                    to[edge_cnt] = v;
                    nxt[edge_cnt] = head[u];
                    head[u] = edge_cnt++;
                    // v -> u
                    to[edge_cnt] = u;
                    nxt[edge_cnt] = head[v];
                    head[v] = edge_cnt++;
                }
            }
        }
    }
}

// BFS on the region‐graph to set up parent[] and depth[]
void bfs_tree() {
    parent = malloc((R+1)*sizeof(int));
    depth  = malloc((R+1)*sizeof(int));
    vis    = calloc(R+1, 1);
    int qh = 0, qt = 0;
    queue_buf[qt++] = 1;  // root at region 1
    vis[1] = 1;
    parent[1] = 1;
    depth[1]  = 0;

    while (qh < qt) {
        int u = queue_buf[qh++];
        for(int e = head[u]; e != -1; e = nxt[e]) {
            int v = to[e];
            if (!vis[v]) {
                vis[v] = 1;
                parent[v] = u;
                depth[v]  = depth[u] + 1;
                queue_buf[qt++] = v;
            }
        }
    }
}

// build binary‐lifting table up[k][v]
void build_lifting() {
    up = malloc(LOG * sizeof(int*));
    for(int k = 0; k < LOG; k++)
        up[k] = malloc((R+1)*sizeof(int));

    for(int v = 1; v <= R; v++)
        up[0][v] = parent[v];

    for(int k = 1; k < LOG; k++) {
        for(int v = 1; v <= R; v++) {
            up[k][v] = up[k-1][ up[k-1][v] ];
        }
    }
}

// lowest common ancestor of u,v in O(LOG)
int lca(int u, int v) {
    if (depth[u] < depth[v]) { int t = u; u = v; v = t; }
    int diff = depth[u] - depth[v];
    for(int k = 0; k < LOG; k++) {
        if (diff & (1<<k)) u = up[k][u];
    }
    if (u == v) return u;
    for(int k = LOG-1; k >= 0; k--) {
        if (up[k][u] != up[k][v]) {
            u = up[k][u];
            v = up[k][v];
        }
    }
    return parent[u];
}

int main(){
    scanf("%d %d", &N, &M);
    terrain  = malloc(N*M);
    region_id= calloc(N*M, sizeof(int));
    queue_buf= malloc(sizeof(int) * (N*M > 1000000 ? N*M : 1000000));

    // read map
    for(int r = 0; r < N; r++){
        char buf[M+1];
        scanf("%s", buf);
        memcpy(terrain + r*M, buf, M);
    }

    // 1) label regions
    label_regions();

    // 2) build region‐adjacency graph
    build_graph();

    // 3) BFS to get parent[] and depth[]
    bfs_tree();

    // 4) binary lifting preprocessing
    build_lifting();

    // 5) answer queries
    scanf("%d", &Q);
    while(Q--){
        int r1,c1,r2,c2;
        scanf("%d %d %d %d",&r1,&c1,&r2,&c2);
        int id1 = region_id[(r1-1)*M + (c1-1)];
        int id2 = region_id[(r2-1)*M + (c2-1)];
        int a   = lca(id1, id2);
        int dist = (depth[id1] + depth[id2] - 2*depth[a]) / 2;
        printf("%d\n", dist);
    }

    return 0;
}
