import sys
from collections import defaultdict

def main():
    data = sys.stdin.read().strip().split()
    T, L = map(int, data[:2])
    bits = data[2]

    # 1) Parse the transition table: each of the T entries is 20 bits long.
    #    First 12 bits = state S, next 8 bits = required opcode for S→S+1.
    codes = [None]*T
    for i in range(T):
        entry = bits[20*i : 20*(i+1)]
        state = int(entry[:12], 2)
        op     = int(entry[12:],   2)
        codes[state] = op

    # 2) Parse the executed‐opcode stream (L bits → N = L/8 opcodes).
    tail = bits[20*T:]
    N = len(tail) // 8
    exec_ops = [int(tail[8*i:8*(i+1)],2) for i in range(N)]

    # 3) Build a reverse‐map: for each opcode, which states expect it?
    want = defaultdict(list)
    for s, op in enumerate(codes):
        want[op].append(s)

    # 4) dp[k] = number of ways to have advanced to state k.
    #    Start in state 0, so dp[0]=1.
    dp = [0]*(T+1)
    dp[0] = 1

    # 5) Scan each executed opcode once; if it matches the transition for state s,
    #    we can extend all ways that had reached s up to reach s+1.
    for op in exec_ops:
        for s in reversed(want.get(op, ())):
            dp[s+1] += dp[s]

    # 6) dp[T] is the number of ways to go from 0→T in order.
    print(dp[T])

if __name__ == "__main__":
    main()
