#include <bits/stdc++.h>
using namespace std;
using vi = vector<int>;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    vector<vi> adj(N+1);
    for(int i = 0; i < N-1; i++){
        int A, B;
        char dash;
        cin >> A >> dash >> B;
        adj[A].push_back(B);
        adj[B].push_back(A);
    }
    int H;
    cin >> H;

    // 1) Iterative DFS to get parent[] and pre-order
    vi parent(N+1, 0), order; order.reserve(N);
    parent[1] = 0;
    vector<int> stk;
    stk.reserve(N);
    stk.push_back(1);
    while(!stk.empty()){
        int u = stk.back(); stk.pop_back();
        order.push_back(u);
        for(int v: adj[u]){
            if(v == parent[u]) continue;
            parent[v] = u;
            stk.push_back(v);
        }
    }

    // 2) Compute subtree sizes by processing in reverse pre-order
    vi sub(N+1, 1);
    for(int i = N-1; i >= 0; --i){
        int u = order[i];
        if(parent[u] != 0)
            sub[parent[u]] += sub[u];
    }

    // 3) Mark the path from H up to 1
    vector<char> onPath(N+1, 0);
    for(int x = H; x != 0; x = parent[x])
        onPath[x] = 1;

    // 4) Find the largest removable subtree not containing H
    int bestCut = 0;
    for(int u = 2; u <= N; u++){
        if(!onPath[u]){
            bestCut = max(bestCut, sub[u]);
        }
    }

    // 5) Minimum exposed = N - bestCut
    cout << (N - bestCut) << "\n";
    return 0;
}
