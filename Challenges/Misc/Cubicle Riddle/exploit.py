#!/usr/bin/env python3
import socket

HOST = "83.136.252.248"
PORT = 44801

MIDDLE_OPCODE_DECIMALS = [
    124,  0,   # LOAD_FAST 0
    68,   0,   # GET_ITER  0
    93,  18,   # FOR_ITER +18
    125,  3,   # STORE_FAST 3  (loop variable “num”)
    124,  3,   # LOAD_FAST 3   (num)
    124,  1,   # LOAD_FAST 1   (min)
    107,  0,   0,  0,  0,  0,   # COMPARE_OP '<', arg=0
    114,  2,   # POP_JUMP_FORWARD_IF_FALSE +2
    124,  3,   # LOAD_FAST 3   (num)
    125,  1,   # STORE_FAST 1  (min = num)
    124,  3,   # LOAD_FAST 3   (num)
    124,  2,   # LOAD_FAST 2   (max)
    107,  4,   0,  0,  0,  0,   # COMPARE_OP '>', arg=4
    114,  2,   # POP_JUMP_FORWARD_IF_FALSE +2
    124,  3,   # LOAD_FAST 3   (num)
    125,  2,   # STORE_FAST 2  (max = num)
    140,  19   # LOAD_CONST 1 (to build the return tuple)
]
# We will turn these into a single comma-separated string:
ANSWER_LINE = ",".join(str(b) for b in MIDDLE_OPCODE_DECIMALS) + "\n"
# ─────────────────────────────────────────────────────────────────────────────

def recv_until(sock: socket.socket, token: bytes, timeout: float = 5.0) -> bytes:
    """
    Read bytes until ‘token’ appears. Raises if we timeout.
    """
    data = b""
    sock.settimeout(timeout)
    while True:
        chunk = sock.recv(4096)
        if not chunk:
            break
        data += chunk
        if token in data:
            return data
    raise TimeoutError(f"Did not see {token!r} before socket closed.\nGot so far: {data!r}")


def main():
    # 1) Connect
    with socket.create_connection((HOST, PORT)) as s:
        print("[+] Connected to", f"{HOST}:{PORT}")

        # 2) Wait for initial “Choose wisely” menu, then send “1\n”
        banner = recv_until(s, b"Choose wisely")
        print(banner.decode(errors="ignore"))
        s.sendall(b"1\n")
        print("[>] Sent “1” to approach the cube.\n")

        # 3) Wait for the riddle prompt “What am i?”
        riddle_banner = recv_until(s, b"What am i?")
        print(riddle_banner.decode(errors="ignore"))

        # 4) Now send exactly the 42 opcode bytes as decimal ASCII, comma-separated, plus newline
        print(f"[>] Sending {len(MIDDLE_OPCODE_DECIMALS)} bytecode integers...")
        s.sendall(ANSWER_LINE.encode())

        # 5) Finally, read & print everything until the socket closes (hopefully the flag)
        try:
            while True:
                chunk = s.recv(4096)
                if not chunk:
                    break
                print(chunk.decode(errors="ignore"), end="")
        except Exception:
            pass

        print("\n[+] Connection closed. If the answer was correct, you should see the flag above.")


if __name__ == "__main__":
    main()
