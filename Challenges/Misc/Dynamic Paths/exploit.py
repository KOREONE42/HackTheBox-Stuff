#!/usr/bin/env python3
# Exploit script for Dynamic Paths challenge
# Connects to the remote instance, retrieves each grid, computes the minimum path sum,
# submits the sum only, and retrieves the flag.

from pwn import remote, context

#--- Configuration ---
REMOTE_IP   = '94.237.57.57'
REMOTE_PORT = 32718
TOTAL_TESTS = 100

#--- Helper functions ---
def get_values(io, test_n):
    """
    Receive dimensions and flat grid for test #test_n.
    """
    io.recvuntil(f"Test {test_n+1}/{TOTAL_TESTS}".encode())
    io.recvline()  # consume end of header
    dims = io.recvline().decode().strip()
    flat = io.recvline().decode().strip()
    return dims, flat


def format_grid(dimensions: str, flat: str):
    """
    Convert "R C" and flat string into a 2D list.
    """
    rows, cols = map(int, dimensions.split())
    nums = list(map(int, flat.split()))
    return [nums[i*cols:(i+1)*cols] for i in range(rows)]


def find_min_path_sum(grid):
    """
    Compute minimum path sum moving only down/right.
    """
    rows, cols = len(grid), len(grid[0])
    dp = [[0]*cols for _ in range(rows)]
    dp[0][0] = grid[0][0]

    for j in range(1, cols):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    for i in range(1, rows):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for i in range(1, rows):
        for j in range(1, cols):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]

    return dp[-1][-1]


#--- Main exploitation flow ---
def pwn():
    context.log_level = 'info'
    io = remote(REMOTE_IP, REMOTE_PORT)

    for t in range(TOTAL_TESTS):
        print(f"[*] Solving test {t+1}/{TOTAL_TESTS}")
        dims, flat = get_values(io, t)
        grid = format_grid(dims, flat)
        min_sum = find_min_path_sum(grid)
        io.sendline(str(min_sum).encode())

    # After all tests, receive the flag
    data = io.recvuntil(b'HTB{') + io.recvline().strip()
    print(f"[+] Retrieved flag: {data.decode()}")
    io.close()

if __name__ == '__main__':
    pwn()
